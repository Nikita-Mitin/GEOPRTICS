/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under Ultimate Liberty license
  * SLA0044, the "License"; You may not use this file except in compliance with
  * the License. You may obtain a copy of the License at:
  *                             www.st.com/SLA0044
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */     

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
//#define UartBufSize 40*40*10

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */





/**************************** GLOBAL VARIABLES ********************************/
uint8_t uart_buf[UartBufSize] = {'\0'};		// —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏–π_–±—É—Ñ–µ—Ä_UART
uint8_t uart_hlf_flag = 0;					// —Ñ–ª–∞–≥_–ø–æ–ª–æ–≤–∏–Ω—ã_–∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è_–±—É—Ñ–µ—Ä–∞
uint8_t data_ready_flag = 0;				// —Ñ–ª–∞–≥_–≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏_–¥–∞–Ω–Ω—ã—Ö_–¥–ª—è_–≤—ã–≤–æ–¥–∞ (—Å–ø–∞—Ä—Å–µ–Ω_—Ö–æ—Ç—è–±_–æ–¥–∏–Ω_–ø–∞–∫–µ—Ç)
string_t datastring[string_amount];			// –º–∞—Å—Å–∏–≤_—Å—Ç—Ä–æ–∫_–¥–∞–Ω–Ω—ã—Ö - 											 											 										   –æ–±—â–µ–µ_–∞–¥—Ä—Å—Å–Ω–æ–µ_–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ_–¥–ª—è_–ø–æ–ª—É—á–∞–µ–º—ã—Ö_–∏_–æ—Ç–ø—Ä–∞–≤–ª—è–µ–º—ã—Ö_—Å—Ç—Ä–æ–∫

uint16_t ADC_val[5];						// –ú–ê–°–°–?–í –•–†–ê–ù–?–¢ –ó–ù–ê–ß–ï–ù–?–ï –ê–¶–ü
												// 0 - –°–ï–ù–°–û–† –¢–ï–ú–ü–ï–†–ê–¢–£–†–´ STM32
												// 1 - –¢–ï–ú–ü.–°–ï–ù–°–û–† –ü–õ–ê–¢–´ 1
												// 2
												// 3
												// 4
uint8_t display_stat = 1;					// –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è_—Å—Ç–∞—Ç—É—Å–∞_–¥–∏—Å–ø–ª–µ—è
uint8_t LEDs_stat;							// –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è_—Å—Ç–∞—Ç—É—Å–∞_—Å–≤–µ—Ç–æ–¥–∏–æ–¥–æ–≤

uint8_t UTC[8] = {'\0'};
uint8_t UTC_show_flag = 0;

uint8_t service_mode = 0;
/******************************************************************************/


/* USER CODE END Variables */
osThreadId defaultTaskHandle;
osThreadId myDisplayTaskHandle;
osThreadId myDataTaskHandle;
osThreadId myControlTaskHandle;
osThreadId myLEDsTaskHandle;
osMessageQId myCursorQueueHandle;
osMessageQId myDispStatQueueHandle;
osMessageQId myDisplayStatHandle;
uint8_t myDisplayStatBuffer[ 4 * sizeof( uint8_t ) ];
osStaticMessageQDef_t myDisplayStatControlBlock;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */
   
/* USER CODE END FunctionPrototypes */

void StartDefaultTask(void const * argument);
void StartDisplayTask(void const * argument);
void StartDataTask(void const * argument);
void StartControlTask(void const * argument);
void StartLEDsTask(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];
  
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}                   
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */
       
  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the queue(s) */
  /* definition and creation of myCursorQueue */
  osMessageQDef(myCursorQueue, 5, uint8_t);
  myCursorQueueHandle = osMessageCreate(osMessageQ(myCursorQueue), NULL);

  /* definition and creation of myDispStatQueue */
  osMessageQDef(myDispStatQueue, 4, uint8_t);
  myDispStatQueueHandle = osMessageCreate(osMessageQ(myDispStatQueue), NULL);

  /* definition and creation of myDisplayStat */
  osMessageQStaticDef(myDisplayStat, 4, uint8_t, myDisplayStatBuffer, &myDisplayStatControlBlock);
  myDisplayStatHandle = osMessageCreate(osMessageQ(myDisplayStat), NULL);

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

  /* definition and creation of myDisplayTask */
  osThreadDef(myDisplayTask, StartDisplayTask, osPriorityNormal, 0, 2800);
  myDisplayTaskHandle = osThreadCreate(osThread(myDisplayTask), NULL);

  /* definition and creation of myDataTask */
  osThreadDef(myDataTask, StartDataTask, osPriorityNormal, 0, 800);
  myDataTaskHandle = osThreadCreate(osThread(myDataTask), NULL);

  /* definition and creation of myControlTask */
  osThreadDef(myControlTask, StartControlTask, osPriorityNormal, 0, 400);
  myControlTaskHandle = osThreadCreate(osThread(myControlTask), NULL);

  /* definition and creation of myLEDsTask */
  osThreadDef(myLEDsTask, StartLEDsTask, osPriorityIdle, 0, 128);
  myLEDsTaskHandle = osThreadCreate(osThread(myLEDsTask), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartDefaultTask */
/************************************************************
 * 															*
 *				 –ü–£–°–¢–ê–Ø –°–¢–ê–ù–î–ê–†–¢–ù–ê–Ø –ó–ê–î–ê–ß–ê					*
 *				 –í–´–ü–û–õ–ù–Ø–ï–¢–°–Ø –¢–û–ì–î–ê, –ö–û–ì–î–ê					*
 *				  –ù–?–ß–ï–ì–û –ù–ï –í–´–ü–û–õ–ù–Ø–ï–¢–°–Ø –?					*
 *				   –ó–ê–ü–£–°–ö–ê–ï–¢ –ü–ï–†–ï–§–ï–†–?–Æ						*
 *				   											*
 ************************************************************/
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
  /* USER CODE BEGIN StartDefaultTask */

/*------------------------- –ó–ê–ü–£–°–ö–ê–ï–ú –ü–ï–†–ï–§–ï–†–?–Æ ---------------------------*/
	HAL_UART_Receive_DMA(&huart3, (uint8_t*)uart_buf, UartBufSize);	// –ó–ê–ü–£–°–ö UART –í –†–ï–ñ–?–ú–ï DMA
	HAL_IWDG_Init(&hiwdg);											// –ó–ê–ü–£–°–ö WATHDOG
	HAL_TIM_Base_Start_IT(&htim7);									// –ó–ê–ü–£–°–ö –¢–ê–ô–ú–ï–†–ê UP_TIME
	HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_val, 5);				// –ó–ê–ü–£–°–ö –ê–¶–ü –í –†–ï–ñ–?–ú–ï DMA
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
  }
  /* USER CODE END StartDefaultTask */
}

/* USER CODE BEGIN Header_StartDisplayTask */
/*
 * –ó–ê–î–ê–ß–ê –†–?–°–û–í–ê–ù–?–Ø –ù–ê –î–?–°–ü–õ–ï–ô
 * –û–¢–ë–?–†–ê–ï–¢ –°–¢–†–û–ö–? –î–õ–Ø –í–´–í–û–î–ê
 * –ü–†–?–ù–?–ú–ê–ï–¢ –ó–ù–ê–ß–ï–ù–?–ï –ö–£–†–°–û–†–ê
 * –í–´–í–û–î–?–¢ –°–¢–†–û–ö–? –ù–ê –î–?–°–ü–õ–ï–ô
 *
 */
/************************************************************
 * 															*
 *				    –ó–ê–î–ê–ß–ê –†–?–°–û–í–ê–ù–?–Ø –ù–ê –î–?–°–ü–õ–ï–ô				*
 *				    –û–¢–ë–?–†–ê–ï–¢ –°–¢–†–û–ö–? –î–õ–Ø –í–´–í–û–î–ê				*
 *				  	–ü–†–?–ù–?–ú–ê–ï–¢ –ó–ù–ê–ß–ï–ù–?–ï –ö–£–†–°–û–†–ê				*
 *				   	–í–´–í–û–î–?–¢ –°–¢–†–û–ö–? –ù–ê –î–?–°–ü–õ–ï–ô				*
 *				   											*
 ************************************************************/
/* USER CODE END Header_StartDisplayTask */
void StartDisplayTask(void const * argument)
{
  /* USER CODE BEGIN StartDisplayTask */

/************************** –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ó–ê–î–ê–ß–? ****************************/

/*-----------------------  –û–°–ù–û–í–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ------------------------- */
	static u8g2_t u8g2;											// TypeDef_–±–∏–±–ª–∏–æ—Ç–µ–∫–∏_u8g2_–¥–ª—è_—Ä–∏—Å–æ–≤–∞–Ω–∏—è_–Ω–∞_–¥–∏—Å–ø–ª–µ–π
	uint16_t cursor = 0;										// –ü–æ–ª–æ–∂–µ–Ω–∏–µ_–æ–∫–æ—à–∫–∞_–¥–∏—Å–ø–ª–µ—è
	string_t *rdy[string_amount];								// –ú–∞—Å—Å–∏–≤_—É–∫–∞–∑–∞—Ç–µ–ª–µ–π_–Ω–∞_–≥–æ—Ç–æ–≤—ã–µ_–∫_–≤—ã–≤–æ–¥—É_—Å—Ç—Ä–æ–∫–∏
//	uint8_t disp_stat = 1;										// –°—Ç–∞—Ç—É—Å_–¥–∏—Å–ø–ª–µ—è. –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è_–ø—Ä–∏—è–Ω—Ç—ã–º_–æ—Ç_–∫–æ–º–ø–∞_–∑–Ω–∞—á–µ–Ω–∏–µ–º
	uint8_t show_pointer = 0;

/*----------------------------- –°–ß–ï–¢–ß–?–ö–? ------------------------------- */
	uint8_t rdy_count = 0;
	uint8_t show_count = 0;
	uint32_t displayOFF_del = 0;

/*----------------------- –§–£–ù–ö–¶–?–? –?–ù–?–¶–ê–õ–?–ó–ê–¶–?–? --------------------------*/
	DisplayInit(&u8g2);											// –?–ù–?–¶–?–ê–õ–?–ó–ê–¶–?–Ø –î–?–°–ü–õ–ï–Ø
	PowerON(&u8g2);

/***************************** –¢–ï–õ–û –ó–ê–î–ê–ß–? *******************************/
	for(;;){

		// –£–°–õ–û–í–?–ï –û–ü–†–ï–î–ï–õ–Ø–Æ–©–ï–ï, –ì–û–¢–û–í–´ –õ–? –î–ê–ù–ù–´–ï –î–õ–Ø –í–´–í–û–î–ê
		// –ï–°–õ–? –ù–ï –ì–û–¢–û–í–´, –í–´–í–û–î–?–¢ –û–ö–ù–û –ó–ê–ì–†–£–ó–ö–?,
		// –?–ù–ê–ß–ï –í–´–ü–û–õ–ù–Ø–ï–¢ –í–´–í–û–î –î–ê–ù–ù–´–• –ù–ê –î–?–°–ü–õ–ï–ô
		if(!(data_ready_flag && uart_hlf_flag) && display_stat){
			display_stat = 3;
		}
		else if (display_stat){

			display_stat = (display_stat == 0) ? 0 : 1;

/*----------------------- –û–¢–ë–?–†–ê–ï–ú –ù–£–ñ–ù–´–ï –°–¢–†–û–ö–? -------------------------*/

			// –ü–†–û–°–ú–ê–¢–†–?–ï–í–ê–ï–ú –í–ï–°–¨ –ú–ê–°–°–?–í –°–¢–†–û–ö –í –ü–û–?–°–ö–ê–• –ì–û–¢–û–í–´–• –°–¢–†–û–ö
			// –ï–°–õ–? –°–¢–†–û–ö–ê –ì–û–¢–û–í–ê, –í –ú–ê–°–°–?–í –£–ö–ê–ó–ê–¢–ï–õ–ï–ô –ó–ê–ü–?–°–´–í–ê–ï–ú –ê–î–†–ï–°–° –ì–û–¢–û–í–û–ô –°–¢–†–û–ö–?
			rdy_count = 0;
			for(uint8_t i = 1; i < start_ctrl_string; i++){
				if(datastring[i].status){
					rdy[rdy_count] = &datastring[i];
					rdy_count++;
				}
			}

/*-------------------–û–ü–†–ï–î–ï–õ–Ø–ï–ú –ü–û–õ–û–ñ–ï–ù–?–ï –û–ö–ù–ê(–ö–£–†–°–û–†–ê) ------------------*/

			// –ü–†–?–ù–?–ú–ê–ï–ú –ó–ù–ê–ß–ï–ù–?–ï –ö–£–†–°–û–†–ê –?–ó –ó–ê–î–ê–ß–? StartControlTask
			xQueueReceive(myCursorQueueHandle, &cursor, 10);

			// –ü–†–û–í–ï–†–Ø–ï–ú, –ß–¢–û –û–ö–ù–û –ù–ï –í–´–•–û–î–?–¢ –ó–ê –ö–û–ù–ï–¶ –í–´–í–û–î–?–ú–´–• –°–¢–†–û–ö(—Ç.–∫_–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_—Å—Ç—Ä–æ–∫_–º–æ–∂–µ—Ç_–º–µ–Ω—è—Ç—å—Å—è)
			// –ï–°–õ–? –í–´–•–û–î–?–¢, –¢–û –ü–†–?–ù–?–ú–ê–ï–ú –ú–ê–ö–°–?–ú–ê–õ–¨–ù–û–ï –? –û–¢–ü–†–ê–í–õ–Ø–ï–ú –ó–ù–ê–ß–ï–ù–?–ï –ó–ê–î–ê–ß–ï StartControlTask
			if(cursor > rdy_count - 1 && cursor < 160){
				cursor = 0;
				xQueueSendToBack(myCursorQueueHandle, &cursor, portMAX_DELAY);
			}
			else if(cursor > 160) {
				cursor = rdy_count-1;
				xQueueSendToBack(myCursorQueueHandle, &cursor, portMAX_DELAY);
			}

/*-------------------------- –†–?–°–£–ï–ú –ù–ê –î–?–°–ü–õ–ï–ô --------------------------*/

			// –ü–†–?–ù–?–ú–ê–ï–ú –°–¢–ê–¢–£–° –î–?–°–ü–õ–ï–Ø –?–ó –ó–ê–î–ê–ß–? StartControlTask
//			taskENTER_CRITICAL();
//			xQueueReceive(myDispStatQueueHandle, &display_stat, 100);
//			taskEXIT_CRITICAL();

			u8g2_ClearBuffer(&u8g2);										// –û–ß–?–©–ê–ï–ú –ë–£–§–ï–† –î–?–°–ü–õ–ï–Ø

			u8g2_SetFont(&u8g2, u8g2_font_unifont_t_cyrillic);				// –£–°–¢–ê–ù–ê–í–õ–?–í–ê–ï–ú –ö–?–†–?–õ–?–ß–ï–°–ö–?–ô –®–†–?–§–¢

			u8g2_SetDrawColor(&u8g2, 2);

			// –í–í–û–î–?–ú –í –ë–£–§–ï–† –î–?–°–ü–õ–ï–Ø 4 –°–¢–†–û–ö–?, –ù–ê–ß–?–ù–ê–Ø –° –ù–ê–ß–ê–õ–ê –ü–û–õ–û–ñ–ï–ù–?–Ø –ö–£–†–°–û–†–ê
//			for(uint8_t i = cursor; i < cursor + 4; i++){
//				if(i > rdy_count) i = 0;
//				u8g2_DrawUTF8(&u8g2, 0, 15+ 15 * (i - cursor),(char *) rdy[i]->buf);
//
//				// –í–í–û–î–?–ú –í –ë–£–§–ï–† –î–?–°–ü–õ–ï–Ø –ó–ù–ê–ö–? –°–?–ú–í–û–õ–û–í –ì–†–ê–î–£–°–ê –°–¢–†–û–ö–? –í –ú–ï–°–¢–ê, –ù–ê –ö–û–¢–û–†–´–• –û–ù–? –†–ê–°–ü–û–õ–û–ñ–ï–ù–´
//				for(uint8_t j = 0; j < degree_sym_amount; j++){
//					if(rdy[i]->degreeSym[j] != '\0')
//					DrawSym(&u8g2, rdy[i]->degreeSym[j] * 7 + 7, 15 + 15 * (i - cursor), 176);
//				}
//			}

			show_count = 4;
			show_pointer = cursor;

			while(show_count){

				u8g2_DrawUTF8(&u8g2, 0, 15+ 15 * (4 - show_count),(char *) rdy[show_pointer]->buf);

				// –í–í–û–î–?–ú –í –ë–£–§–ï–† –î–?–°–ü–õ–ï–Ø –ó–ù–ê–ö–? –°–?–ú–í–û–õ–û–í –ì–†–ê–î–£–°–ê –°–¢–†–û–ö–? –í –ú–ï–°–¢–ê, –ù–ê –ö–û–¢–û–†–´–• –û–ù–? –†–ê–°–ü–û–õ–û–ñ–ï–ù–´
				for(uint8_t j = 0; j < degree_sym_amount; j++){
					if(rdy[show_pointer]->degreeSym[j] != '\0')
					DrawSym(&u8g2, rdy[show_pointer]->degreeSym[j] * 7 + 7, 15 + 15 * (4 - show_count), 176);
				}

				show_pointer = (show_pointer <= rdy_count - 2) ? show_pointer + 1 : 0;
				show_count--;
			}

			if(UTC_show_flag){
				u8g2_SetFontMode(&u8g2, 1);
				u8g2_DrawBox(&u8g2, 0, 0, 254, 15);
				u8g2_SetDrawColor(&u8g2, 2);
				u8g2_DrawUTF8(&u8g2, 0, 15,(char *) &UTC);
			}
		}
//			// –û–¢–ü–†–ê–í–õ–Ø–ï–ú –ë–£–§–ï–† –ë–ï–ó –†–ï–ñ–?–ú–û–í (–î–õ–Ø –û–¢–õ–ê–î–ö–?)
//			u8g2_SendBuffer(&u8g2);

//			 –í–´–ë–?–†–ê–ï–ú, –ß–¢–û –î–ï–õ–ê–¢–¨ –° –í–í–ï–î–ï–ù–ù–´–ú–? –î–ê–ù–ù–´–ú–?, –û–°–ù–û–í–´–í–ê–Ø–°–¨ –ù–ê –°–¢–ê–¢–£–°–ï –î–?–°–ü–õ–ï–Ø
//			 0 - –ù–ê –î–?–°–ü–õ–ï–ô –ù–?–ß–ï–ì–û –ù–ï –í–´–í–û–î–?–¢–°–Ø
//			 1 - –î–?–°–ü–õ–ï–ô –†–ê–ë–û–¢–ê–ï–¢ –í –ù–û–†–ú–ê–õ–¨–ù–û–ú –†–ï–ñ–?–ú–ï, –? –ó–ê–°–´–ü–ê–ï–¢ –ü–û–°–õ–ï UP_TIME(–†–ï–î–ö–û)
//			 2 - –î–?–°–ü–õ–ï–ô –†–ê–ë–û–¢–ê–ï–¢ –í –†–ï–ñ–?–ú–ï –°–ù–ê –? –ó–ê–°–´–ü–ê–ï–¢ –ü–û–°–õ–ï UP_TIME_small(–ß–ê–°–¢–û)

		switch (display_stat){
		case 0:
			displayOFF_del = HAL_GetTick();

			while(HAL_GetTick() - displayOFF_del < PowerOFF_delay - 10){
				u8g2_ClearDisplay(&u8g2);
				OFF_Window(&u8g2);
			}
			u8g2_ClearDisplay(&u8g2);
			vTaskDelete(myDisplayTaskHandle);
			break;
		case 1:
			if(uptime_tick - uptime < UP_TIME){
				u8g2_SendBuffer(&u8g2);
			}
			else{
				u8g2_ClearDisplay(&u8g2);
			}
			break;
		case 2:
			if(uptime_tick - uptime < UP_TIME_small){
				u8g2_SendBuffer(&u8g2);
			}
			else{
				u8g2_ClearDisplay(&u8g2);
			}
			break;
		case 3:
			u8g2_ClearBuffer(&u8g2);
			LoadWindow(&u8g2, logo_width, logo_height,(uint8_t *) &logo_bits);
			u8g2_SendBuffer(&u8g2);
		}

		// –ü–ï–†–ï–í–û–î–?–ú –ó–ê–î–ê–ß–£ –í –†–ï–ñ–?–ú –û–ñ–?–î–ê–ù–?–Ø (–º—Å)
		osDelay(10);
	}
  /* USER CODE END StartDisplayTask */
}

/* USER CODE BEGIN Header_StartDataTask */
/************************************************************
 * 															*
 * 				 –ó–ê–î–ê–ß–ê –ü–ê–†–°–ï–†–ê –ü–ê–ö–ï–¢–û–í UART				*
 *		–ü–ê–†–°–?–¢ –°–¢–†–û–ö–? –í –ú–ê–°–°–?–í string_t datastring[]		*
 *					–?–ù–î–ï–ö–° - –ù–û–ú–ï–† –°–¢–†–û–ö–?					*
 *				–ü–†–û–í–ï–†–Ø–ï–¢ –ü–ê–ö–ï–¢ –ù–ê –¶–ï–õ–û–°–¢–ù–û–°–¢–¨				*
 *															*
*************************************************************/
/* USER CODE END Header_StartDataTask */
void StartDataTask(void const * argument)
{
  /* USER CODE BEGIN StartDataTask */

/************************** –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ó–ê–î–ê–ß–? ****************************/

		/*- - - - - - - -  –û–°–ù–û–í–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï - - - - - - - - - */
	uint16_t stringnum = 0;										// –•–†–ê–ù–?–¢ –ù–û–ú–ï–† –¢–ï–ö–£–©–ï–ô –°–¢–†–û–ö–?
	buffer_t crc32_buf;											// –ë–£–§–ï–†, –í –ö–û–¢–û–†–´–ô –ó–ê–ü–?–°–´–í–ê–Æ–¢–°–Ø –î–ê–ù–ù–´–ï –î–õ–Ø –†–ê–°–ß–ï–¢–ê –°RC32
	char strnumhex[2];											// –°–?–ú–í–û–õ–¨–ù–´–ô –ë–£–§–ï–†, –•–†–ê–ù–Ø–©–?–ô –ù–û–ú–ï–† –°–¢–†–û–ö–? –≤ hex

		/*- - - - - - - - - - - –°–ß–ï–¢–ß–?–ö–?  - - - - - - - - - - - -*/
	uint16_t counter = 0;										// –°–ß–ï–¢–ß–?–ö –¶–?–ö–õ–?–ß–ï–°–ö–û–ì–û –ë–£–§–ï–†–ê (–ê–¢–ê–í–?–ó–ú)
	uint16_t pointer = 0;										// –£–ö–ê–ó–ê–¢–ï–õ–¨ –ù–ê –°–?–ú–í–û–õ –ë–£–§–ï–†–ê uart_buf
	uint8_t celsium_count = 0;									// –°–ß–ï–¢–ß–?–ö –î–õ–Ø –ó–ê–ü–û–õ–ù–ï–ù–?–Ø –ó–ù–ê–ö–û–í –ì–†–ê–î–£–°–ê –¶–ï–õ–¨–°–?–Ø
	uint8_t string_count = 0;									// –°–ß–ï–¢–ß–?–ö –î–õ–Ø –ó–ê–ü–û–õ–ù–ï–ù–?–Ø –°–¢–†–û–ö
	uint32_t restart_val = 0;
	uint8_t UTC_count = 0;
	uint16_t UTC_pointer = 0;

	osDelay(500);
/***************************** –¢–ï–õ–û –ó–ê–î–ê–ß–? *******************************/
	for(;;){

		// –ï–°–õ–? RX –ù–ï –í –ü–†–û–°–¢–û–ï, –¢–û –ñ–î–ï–ú –û–ü–†–ï–î–ï–õ–ï–ù–ù–û–ï –í–†–ï–ú–Ø
		// –? –ù–ê–ß–?–ù–ê–ï–ú –ü–û–?–°–ö –°–¢–ê–†–¢–û–í–û–ô –ö–û–ú–ë–?–ù–ê–¶–?–?
		// –£–°–õ–û–í–?–ï –ü–û–ú–ê–ì–ê–ï–¢ –ü–ê–†–°–?–¢–¨ –ù–û–í–´–ô –ü–ê–ö–ï–¢ –û–î–?–ù –†–ê–ó
		if(!(USART3->SR & USART_SR_IDLE)){
			restart_val = HAL_GetTick();

			HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_RESET);

			osDelay(pack_DELAY);

			counter = UartBufSize;

			// –¢–ï–õ–û –ü–ê–†–°–ï–†–ê:
			// –ü–†–û–ë–ï–ì–ê–ï–¢ –í–ï–°–¨ –ë–£–§–ï–† –í –ü–û–?–°–ö–ê–• –°–¢–ê–†–¢–û–í–û–ô –ö–û–ú–ë–?–ù–ê–¶–?–?
			// –ü–û–°–õ–ï –¢–û–ì–û, –ö–ê–ö –ù–ê–ô–î–ï–¢, –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–¢ –ü–ê–ö–ï–¢ –? –í–´–•–û–î–?–¢ –?–ó –¢–ï–õ–ê –¶–?–ö–õ–ê
			while(counter){

				// –ï–°–õ–? –ù–ê–ô–î–ï–ù–ê –°–¢–ê–†–¢–û–í–ê–Ø –ö–û–ú–ë–?–ù–ê–¶–?–Ø, –¢–û –ù–ê–ß–?–ù–ê–ï–ú –ü–ê–†–°–?–¢–¨
				if(FindString((uint8_t *)&uart_buf, UartBufSize, &pointer,"PDS", 3)){


					// –ü–†–û–ü–£–°–ö–ê–ï–ú –°–?–ú–í–û–õ ';'
					PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 1);

					// –†–ê–°–ß–?–¢–´–í–ê–ï–ú CRC32, –ï–°–õ–? CRC –°–û–®–ï–õ–°–Ø, –ü–†–û–î–û–õ–ñ–ê–ï–ú –ü–ê–†–°–?–¢–¨
					// –?–ù–ê–ß–ï –û–°–¢–ê–ù–ê–í–õ–?–í–ê–ï–ú –ü–ê–†–°–?–ù–ì: –§–£–ù–ö–¶–?–Ø –ó–ê–ü–?–°–´–í–ê–ï–¢ –? –û–®–?–ë–ö–? CRC
					if(CRC32_Status((uint8_t *)&uart_buf, UartBufSize, pointer, &crc32_buf)){}
					else break;

					// –¶–?–ö–õ –ü–ê–†–°–?–¢ string_pack_amount –°–¢–†–û–ö –ü–û –û–¢–î–ï–õ–¨–ù–û–°–¢–?
					for(uint8_t i = 0; i < string_pack_amount; i++){

						// –ï–°–õ–? –í–ú–ï–°–¢–û –ù–û–ú–ï–†–ê –°–¢–†–û–ö–? –ù–ê–ô–î–ï–ù–ê –ö–û–ú–?–ù–ê–¶–?–Ø CRC - –ü–ê–ö–ï–¢ –û–ö–û–ù–ß–ï–ù, –í–´–•–û–î–?–ú –?–ó –ü–ê–†–°–?–ù–ì–ê
						if(FindString((uint8_t *)&uart_buf, UartBufSize, &pointer, "CRC", 3)){
							break;
						}

						string_count = 0;
						celsium_count = 0;

						// –ù–û–ú–ï–† –°–¢–†–û–ö–? –í–°–ï–ì–î–ê –°–û–°–¢–û–?–¢ –?–ó –î–í–£–• –°–?–ú–í–û–õ–û–í
						// –ü–ê–†–°–?–ú –ü–ï–†–í–´–ô –°–?–ú–í–û–õ –? –ü–ï–†–ï–•–û–î–?–ú –ö –°–õ–ï–î–£–Æ–©–ï–ú–£
						strnumhex[0] = uart_buf[pointer];
						PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 1);

						// –ü–ê–†–°–?–ú –í–¢–û–†–û–ô –°–?–ú–í–û–õ –? –ü–†–û–ü–£–°–ö–ê–ï–ú 2 –°–?–ú–í–û–õ–ê: –≠–¢–û–¢ –? ';'
						strnumhex[1] = uart_buf[pointer];
						PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 2);

						// –ü–ï–†–ï–í–û–î–?–ú –°–¢–†–û–ö–£ –ù–û–ú–ï–†–ê: (char, hex) -> (int, dec)
						stringnum = HexToDec((char *) &strnumhex,2);
						datastring[stringnum].number = stringnum;

						// –ü–ê–†–°–?–ú –°–û–î–ï–†–ñ–?–ú–û–ï –°–¢–†–û–ö–?:
						// –ü–û–ö–ê –ù–ï –ù–ê–ô–î–ï–ú –ó–ù–ê–ö ';' –?–õ–? –°–¢–†–û–ö–ê –ù–ï –ó–ê–ö–û–ù–ß–?–¢–°–Ø
						// –ö–õ–ê–î–ï–ú –ö–ê–ñ–î–´–ô –°–?–ú–í–û–õ –°–û–î–ï–†–ñ–?–ú–û–ì–û –ë–£–§–ï–†–ê –ù–ê–ß–?–ù–ê–Ø –° pointer
						// –í –ë–£–§–ï–† –°–¢–†–û–ö–? –ù–ê–ß–?–ù–ê–Ø –° string_count (0)
						while((uart_buf[pointer] != (uint8_t)';') && (string_count < string_size)){

							// –ï–°–õ–? –ù–ê–ô–î–ï–ù–ê –ö–û–ú–ë–?–ù–ê–¶–?–Ø DEL, –ó–ù–ê–ß–?–¢ –°–¢–†–û–ö–£ –ù–£–ñ–ù–û –£–î–ê–õ–?–¢–¨ (–°–¢–ê–¢–£–° –°–¢–†–û–ö–? = 0)
							// –? –ü–ê–†–°–?–ù–ì –°–û–î–ï–†–ñ–?–ú–û–ì–û –°–¢–†–û–ö–? –ü–†–ï–ö–†–ê–©–ê–ï–¢–°–Ø
							// –?–ù–ê–ß–ï –°–¢–ê–¢–£–° –°–¢–†–û–ö–? = 1
							if(FindString((uint8_t *)&uart_buf, UartBufSize, &pointer, "DEL", 3) && !string_count){
								datastring[stringnum].status = 0;
								break;
							}
							else if(!string_count) datastring[stringnum].status = 1;

							UTC_pointer = pointer;

							if(FindString((uint8_t *)&uart_buf, UartBufSize, &UTC_pointer, "UTC", 3)){

								UTC_count = 0;

								while(UTC_count < 8){
									UTC[UTC_count] = uart_buf[UTC_pointer];
									UTC_pointer++;
									UTC_count++;
								}
							}

							// –ï–°–õ–? –ù–ê–ô–î–ï–ù–ê –ö–û–ú–ë–?–ù–ê–¶–?–Ø "*C" –í–ú–ï–°–¢–û –ù–ï–ï –ö–õ–ê–î–ï–ú –í –°–¢–†–û–ö–£ ' '
							// –? –ó–ê–ü–?–°–´–í–ê–ï–ú –ü–û–õ–û–ñ–ï–ù–?–ï –ó–ù–ê–ö–ê –ì–†–ê–î–£–°–ê (string_count)
							if(FindString((uint8_t *)&uart_buf,UartBufSize,&pointer,"*C",2)){
								datastring[stringnum].buf[string_count] = (uint8_t)' ';
								datastring[stringnum].degreeSym[celsium_count] = string_count;
								string_count++;
								celsium_count++;
							}

							// –ï–°–õ–? –ù–? –û–î–ù–ê –?–ó –ö–û–ú–ë–?–ù–ê–¶–?–ô –ù–ï –ë–´–õ–ê –ù–ê–ô–î–ï–ù–ê
							// –ü–†–û–°–¢–û –ö–õ–ê–î–ï–ú –°–?–ú–í–û–õ –ë–£–§–ï–†–ê –í –°–¢–†–û–ö–£
							datastring[stringnum].buf[string_count] = uart_buf[pointer];
							PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 1);
							string_count++;
						}

						// –ö–û–ì–î–ê –°–¢–†–û–ö–ê –£–ñ–ï –ó–ê–ü–û–õ–ù–ï–ù–ê –î–ê–ù–ù–´–ú–?,
						// –û–ß–?–©–ê–ï–ú –û–°–¢–ê–í–®–?–ï–°–Ø –≠–õ–ï–ú–ï–ù–¢–´ –í –ë–£–§–ï–†–ï –°–¢–†–û–ö–?
						while(string_count < string_size){
							datastring[stringnum].buf[string_count] = '\0';
							string_count++;
						}
						// –ü–†–û–ü–£–°–ö–ê–ï–ú ';'
						PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 1);
					}

					// –°–¢–ê–í–?–ú –§–õ–ê–ì –ì–û–¢–û–í–ù–û–°–¢–? –î–ê–ù–ù–´–•, –î–õ–Ø –í–´–•–û–î–ê –?–ó –ó–ê–ì–†–£–ó–û–ß–ù–û–ì–û –û–ö–ù–ê
					// –? –í–´–•–û–î–?–ú –?–ó –ü–ê–†–°–ï–†–ê –ü–ê–ö–ï–¢–ê
					data_ready_flag = 1;
					break;
				}

				// –ï–°–õ–? PSD –ù–ï –ù–ê–ô–î–ï–ù, –ü–†–û–ü–£–°–ö–ê–ï–ú –°–?–ú–í–û–õ –ó–ê –°–?–ú–í–û–õ–û–ú –ü–û–ö–ê –ë–£–§–ï–† –ù–ï –ö–û–ù–ß–?–¢–°–Ø
				PassSym((uint8_t *)&uart_buf,UartBufSize,&pointer,1);
				counter--;
			}
			if(!counter){
				// –í–´–í–û–î–?–ú –û–®–?–ë–ö–£, –ß–¢–û –°–¢–ê–†–¢–û–í–ê–Ø –ö–û–ú–ë–?–ù–ê–¶–?–Ø –ù–ï –ë–´–õ–ê –ù–ê–ô–î–ï–ù–ê
				PutERROR((string_t *)&datastring,"PACK_NOT_FOUND");
			}
		}

		// –ï–°–õ–? –î–ê–ù–ù–´–ï –ù–ï –û–ë–ù–û–í–õ–Ø–Æ–¢–°–Ø –ö–ê–ö–û–ï –¢–û –í–†–ï–ú–Ø,
		// –ü–ï–†–ï–ó–ê–ü–£–°–ö–ê–ï–ú UART, –î–õ–Ø –?–ó–ë–ï–ñ–ê–ù–?–Ø –í–û–ó–ú–û–ñ–ù–´–• –û–®–?–ë–û–ö
		if(HAL_GetTick() - restart_val > restart_time){
			HAL_UART_DMAStop(&huart3);
			HAL_UART_Receive_DMA(&huart3, (uint8_t*)uart_buf, UartBufSize);
		}

		if(HAL_GetTick() - restart_val > mother_wdgtime){
			HAL_GPIO_WritePin(STM32_Relay_mother_GPIO_Port, STM32_Relay_mother_Pin, GPIO_PIN_RESET);
			osDelay(1000);
			HAL_GPIO_WritePin(STM32_Relay_mother_GPIO_Port, STM32_Relay_mother_Pin, GPIO_PIN_SET);
		}

		// –û–ë–ù–ê–í–õ–Ø–ï–ú WATHDOG
		HAL_IWDG_Refresh(&hiwdg);

//		if(!HAL_GPIO_ReadPin(STM32_BUTTON_POWER_GPIO_Port, STM32_BUTTON_POWER_Pin)){
			HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_SET);
//		}
		// –ü–ï–†–ï–í–û–î–?–ú –ó–ê–î–ê–ß–£ –í –†–ï–ñ–?–ú –û–ñ–?–î–ê–ù–?–Ø. –í–†–ï–ú–Ø –ú–ê–õ–û, –ß–¢–û–ë –ù–ï –ü–†–û–ü–£–°–¢–¨ –ü–ê–ö–ï–¢
		osDelay(10);
	}
  /* USER CODE END StartDataTask */
}

/* USER CODE BEGIN Header_StartControlTask */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 														   *
 *				 –ó–ê–î–ê–ß–ê –û–ë–†–ê–ë–û–¢–ö–? –°–õ–£–ñ–ï–ë–ù–´–• –°–¢–†–û–ö		   *
 *				  –? –°–û–°–¢–ê–í–õ–ï–ù–?–Ø –°–¢–†–û–ö –ù–ê –û–¢–ü–†–ê–í–ö–£		   *
 *														   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* USER CODE END Header_StartControlTask */
void StartControlTask(void const * argument)
{
  /* USER CODE BEGIN StartControlTask */

/************************** –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ó–ê–î–ê–ß–? ****************************/

/*-------------------- –®–ê–ë–õ–û–ù–´ –î–õ–Ø –ó–ê–ü–û–õ–ù–ï–ù–?–Ø –°–¢–†–û–ö ---------------------*/
	const uint8_t ctrl_template[] = "R?R?R?R?DC?";				// –®–ê–ë–õ–û–ù –î–õ–Ø –°–¢–†–û–ö–? –° –î–ê–ù–ù–´–ú–? O –†–ï–õ–ï –? DC
	const uint8_t but_template[] = 	"B?B?B?PB?";				// –®–ê–ë–õ–û–ù –î–õ–Ø –°–¢–†–û–ö–? –° –î–ê–ù–ù–´–ú–? –°–û–°–¢–û–Ø–ù–? –ö–ù–û–ü–û–ö

/*-------------------------- –ü–ï–†–ï–ú–ï–ù–ù–´–ï CRC32 ---------------------------*/
	uint16_t crc_count = 0;										// –°–ß–ï–¢–ß–?–ö –î–õ–Ø –û–ü–†–ï–î–ï–õ–ï–ù–?–Ø –†–ê–ó–ú–ï–†–ê CRC32
	uint8_t crc_hex_buf[10];									// –°–?–ú–í–û–õ–¨–ù–´–ô –ë–£–§–ï–†, –•–†–ê–ù–Ø–©–?–ô –ó–ê–ü–?–°–¨ CRC32 –í hex
	int32_t crc32;												// –•–†–ê–ù–?–¢ –†–ê–°–ß–?–¢–ê–ù–û–ï –ó–ù–ê–Ø–ï–ù–?–ï CRC32

/*------------------------- –ü–ï–†–ï–ú–ï–ù–ù–´–ï RELE/DC --------------------------*/
	ctrl_status active;											// –ü–ï–†–ï–ú–ï–ù–ù–ê–Ø –°–¢–†–£–ö–¢–£–†–´ –°–¢–†–û–ö –†–ï–õ–ï/DC
	uint16_t RELE_PINS[] = {STM32_OUT_REL_1_Pin, 				// –ú–ê–°–°–?–í, –•–†–ê–ù–Ø–©–?–ô –ù–û–ú–ï–†–ê –ü–?–ù–û–í –†–ï–õ–ï
							STM32_OUT_REL_2_Pin, 					//
							STM32_OUT_REL_3_Pin, 					//
							STM32_OUT_REL_4_Pin};					//
	GPIO_TypeDef *RELE_PORTS[] = {STM32_OUT_REL_1_GPIO_Port, 	// –ú–ê–°–°–?–í, –•–†–ê–ù–Ø–©–?–ô –ù–û–ú–ï–†–ê –ü–û–†–¢–û–í –†–ï–õ–ï
								STM32_OUT_REL_2_GPIO_Port, 			//
								STM32_OUT_REL_3_GPIO_Port, 			//
								STM32_OUT_REL_4_GPIO_Port};			//
	uint8_t RB_count = 0;										// –†–ï–õ–ï/DC –°–ß–ï–¢–ß–?–ö

/*--------------------------- –§–õ–ê–ì–? –°–û–°–¢–û–Ø–ù–?–Ø ---------------------------*/
	uint8_t switch_off = 0;										// –§–õ–ê–ì –í–´–ö–õ–Æ–ß–ï–ù–?–Ø –ü–?–¢–ê–ù–?–Ø
	uint8_t flash_on = 0;										// –§–õ–ê–ì –ó–ê–ü–?–°–? –í –§–õ–≠–®

/*--------------------------- –í–°–ï –î–õ–Ø –ö–ù–û–ü–û–ö ----------------------------*/
	uint8_t but_buf[4];											// –ë–£–§–ï–† –•–†–ê–ù–?–¢ –°–û–°–¢–û–Ø–ù–?–ï 4-–ß –ö–ù–û–ü–û–ö
																	// (0, 1 - –ü–†–û–ö–†–£–¢–ö–ê; 2 - –§–õ–≠–®; 3 - –í–´–ö–õ–Æ–ß–ï–ù–?–ï)
	uint8_t cursor = 0;											// –ü–û–õ–û–ñ–ï–ù–?–ï –ö–£–†–°–û–†–ê
	uint8_t butmem = 0;											// –ü–ï–†–ï–ú–ï–ù–ù–ê–Ø –ó–ê–ü–û–ú–?–ù–ê–ï–¢ –°–û–°–¢–û–Ø–ù–?–ï –ö–ù–û–ü–û–ö
	uint8_t power_butmem = 0;
	uint32_t butthold = 0;										// –ü–ï–†–ï–ú–ï–ù–ù–ê–Ø –î–õ–Ø –û–¢–°–ß–ï–¢–ê –í–†–ï–ú–ï–ù–? –ù–ê–ñ–ê–¢–?–Ø –ö–ù–û–ü–ö–?
	uint32_t power_butthold = 0;

/*----------------------- –ë–£–§–ï–† –ù–ê –û–¢–ü–†–ê–í–ö–£ UART ------------------------*/
	uint8_t sendBuf[ctrl_string_amnt*string_size] = {'\0'};		// –û–¢–ü–†–ê–í–õ–Ø–ï–ú–´–ô –ü–û UART –ë–£–§–ï–†
	uint16_t sB_pointer = 0;									// –£–ö–ê–ó–ê–¢–ï–õ–¨ –ë–£–§–ï–†–ê
	uint8_t sB_counter = 0;										// –°–ß–ï–¢–ß–?–ö –ë–£–§–ï–†–ê
	uint32_t transmit_timer = 0;								// –°–û–•–†–ê–ù–Ø–ï–¢ –í–†–ï–ú–Ø –ü–û–°–õ–ï–î–ù–ï–ô –û–¢–ü–†–ê–í–ö–?

/*--------------------------- –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ê–¶–ü ---------------------------*/
	uint8_t ADC_char[4];										// –ë–£–§–ï–† –î–õ–Ø –ü–ï–†–ï–í–û–î–ê –ó–ù–ê–ß–ï–ù–?–Ø –ê–¶–ü –í –°–¢–†–û–ö–£
	char up_time_char[10];
	uint8_t adc_count = 0;			 							// –°–ß–ï–¢–ß–?–ö –ê–¶–ü
	uint8_t adc_str_count = 0;									// –°–ß–ï–¢–ß–?–ö –°–¢–†–û–ö –ê–¶–ü
	uint8_t opt_buf[6] = {0};

	uint32_t service_hold = 0;
	uint8_t service_mem = 0;
	uint8_t service_mem2 = 0;

	uint8_t con_mem = 0;
/*-------------------------- –§–£–ù–ö–¶–?–? –ó–ê–ü–£–°–ö–ê ----------------------------*/
//	HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_val,5);			// –ó–ê–ü–£–°–ö –ê–¶–ü –í –†–ï–ñ–?–ú–ï DMA



	osDelay(500);
/***************************** –¢–ï–õ–û –ó–ê–î–ê–ß–? *******************************/
	for(;;){

/*--------------------- –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –ù–ê–ñ–ê–¢–?–Ø –ö–ù–û–ü–û–ö ---------------------*/

		// –ü–†–?–ù–?–ú–ê–ï–ú –ó–ù–ê–ß–ï–ù–?–ï –ö–£–†–°–û–† –?–ó –ó–ê–î–ê–ß–? StartDisplayTask
		xQueueReceive(myCursorQueueHandle,&cursor, 10);

		// –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –ö–ù–û–ü–ö–? –ü–†–û–ö–†–£–¢–ö–? –î–?–°–ü–õ–ï–Ø
		ScrollingButtonHandler(&cursor, &butthold, &butmem);

		// –û–¢–ü–†–ê–í–õ–Ø–ï–ú –û–ë–ù–û–í–õ–ï–ù–ù–û–ï –ó–ù–ê–ß–ï–ù–?–ï –ö–£–†–°–û–†–ê –û–ë–†–ê–¢–ù–û –í –ó–ê–î–ê–ß–£ StartDisplayTask
		xQueueSendToBack(myCursorQueueHandle, &cursor, 10);

		// –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –ö–ù–û–ü–ö–£ –û–¢–ö–õ–Æ–ß–ï–ù–?–Ø –ü–?–¢–ê–ù–?–Ø
		PowerButtonHandler(&power_butthold, &power_butmem, &switch_off, OFF_delay - 1000);

		ServiceModeButtonHandler(&service_mem, &service_mem2, &service_hold, service_but_delay);

		ConnHandler(&con_mem);

/*----------- –ó–ê–ü–?–°–´–í–ê–ï–ú –°–û–°–¢–û–Ø–ù–?–ï –ö–ù–û–ü–û–ö –í –ú–ê–°–°–?–í –°–û–°–¢–û–Ø–ù–?–Ø -----------*/
		if(butmem & STM32_BUTTON_2_Pin){
			flash_on = 1;
			UTC_show_flag = 1;
		}
		else UTC_show_flag = 0;

		but_buf[0] = butmem & STM32_BUTTON_1_Pin;						// –ö–ù–û–ü–ö–ê –ü–†–û–ö–£–†–¢–ö–? –í–ù–?–ó
		but_buf[1] = butmem & STM32_BUTTON_2_Pin;						// –ö–ù–û–ü–ö–ê –ü–†–û–ö–†–£–¢–ö–? –í–í–ï–†–•
		but_buf[2] = flash_on;											// –ö–ù–û–ü–ö–ê –ó–ê–ü–?–°–? –í–û –§–õ–≠–®
		but_buf[3] = switch_off;										// –ö–ù–û–ü–ö–ê –í–´–ö–õ–Æ–ß–ï–ù–?–Ø

		opt_buf[0] = HAL_GPIO_ReadPin(STM32_R_24_NO_GPIO_Port,STM32_R_24_NO_Pin);
		opt_buf[1] = HAL_GPIO_ReadPin(STM32_R_24_NC_GPIO_Port,STM32_R_24_NC_Pin);
		opt_buf[2] = HAL_GPIO_ReadPin(INPUT_OUTSIDE_1_GPIO_Port,INPUT_OUTSIDE_1_Pin);
		opt_buf[3] = HAL_GPIO_ReadPin(INPUT_OUTSIDE_2_GPIO_Port,INPUT_OUTSIDE_2_Pin);
		opt_buf[4] = HAL_GPIO_ReadPin(STM32_Conn_1_GPIO_Port,STM32_Conn_1_Pin);
		opt_buf[5] = HAL_GPIO_ReadPin(STM32_Conn_2_GPIO_Port,STM32_Conn_2_Pin);

/*--------------- –û–ë–†–ê–ë–û–¢–ê–í–ê–ï–ú –∏ –í–´–í–û–î–?–ú –°–?–ì–ù–ê–õ–´ –ù–ê –ü–?–ù–´ ---------------*/

		// –ü–ê–†–°–?–ú –°–õ–£–ñ–ï–ë–ù–´–ï –°–¢–†–û–ö–?
		ServiceStringPars((string_t *) &datastring, &active);

		// –ú–ê–°–°–?–í –ó–ê–î–ê–ï–¢ –°–û–°–¢–û–Ø–ù–?–ï –†–ï–õ–ï, –í–ó–ê–?–í–?–°–û–°–¢–? –û–¢ –ü–û–õ–£–ß–ï–ù–ù–´–• –î–ê–ù–ù–´–•
		for(uint8_t i = 0; i < 4; i++){
			if(active.RELE[i])
				HAL_GPIO_WritePin(RELE_PORTS[i], RELE_PINS[i], GPIO_PIN_SET);
			else
				HAL_GPIO_WritePin(RELE_PORTS[i], RELE_PINS[i], GPIO_PIN_RESET);
		}

		// –°–û–°–¢–û–Ø–ù–?–ï –î–?–°–ü–õ–ï–Ø –û–¢–ü–†–ê–í–õ–Ø–ï–¢–°–Ø –í –ó–ê–î–ê–ß–£ StartDisplayTask
//		xQueueSendToBack(myDispStatQueueHandle, &active.DISP, portMAX_DELAY);

/*------------------------- –°–û–°–¢–ê–í–õ–Ø–ï–ú –°–¢–†–û–ö–? --------------------------*/

		// –ü–†–û–ë–ï–ì–ê–ï–ú –í–°–ï –°–¢–†–û–ö–? –ö–ù–û–¢–†–û–õ–Ø (–¶–?–ö–õ –¢–£–¢ –õ–?–®–ù–?–ô, –ù–û –ü–£–°–¢–¨ –ü–û–ö–ê –ë–£–î–ï–¢)
		for(uint8_t i = start_ctrl_string; i < start_serv_string; i++){
			switch (i){

		/*- - - - - - - -  –°—Ç—Ä–æ–∫–∞_‚Ññ2_(–†–ï–õ–ï/DC) - - - - - - - -*/
			case ctrl_string_2:

				RB_count = 0;

				// –ó–ê–ü–û–õ–ù–Ø–ï–ú –°–¢–†–û–ö–£, –?–°–ü–û–õ–¨–ó–£–Ø –®–ê–ë–õ–û–ù
				for(uint8_t j = 0; j < strlen((const char *)&ctrl_template);j++){

					// –ï–°–õ–? –°–?–ú–í–û–õ –®–ê–ë–õ–û–ù–ê 'R', –ó–ê–ü–?–°–´–í–ê–ï–ú –°–û–°–¢–û–Ø–ù–?–ï –†–ï–õ–ï(RB_COUNT –ü–û –°–ß–ï–¢–£)
					if(ctrl_template[j] == (uint8_t)'R'){
						datastring[i].buf[j] = ctrl_template[j];
						datastring[i].buf[j+1] = active.RELE[RB_count] + 48; 	// + 48 - –ü–ï–†–ï–í–û–î–?–¢ –°–?–ú–í–û–õ –?–ó INT –í CHAR
						RB_count++;
					}

					// –ï–°–õ–? –ù–ê–•–û–î–?–ú –ö–û–ú–ë–?–ù–ê–¶–?–Æ "DC", –ó–ê–ü–?–°–´–í–ê–ï–ú –°–û–°–¢–û–Ø–ù–?–ï DC
					if(ctrl_template[j] == (uint8_t)'D' && ctrl_template[j+1] == (uint8_t)'C'){
						datastring[i].buf[j] = ctrl_template[j];
						datastring[i].buf[j+1] = ctrl_template[j+1];
						datastring[i].buf[j+2] = active.DC + 48;				// + 48 - –ü–ï–†–ï–í–û–î–?–¢ –°–?–ú–í–û–õ –?–ó INT –í CHAR
					}
				}
				break;

		/*- - - - - - - - -  –°—Ç—Ä–æ–∫–∞_‚Ññ3_(–ö–ù–û–ü–ö–?) - - - - - - - -*/
			case ctrl_string_3:

				RB_count = 0;

				// –ó–ê–ü–û–õ–ù–Ø–ï–ú –°–¢–†–û–ö–£, –?–°–ü–û–õ–¨–ó–£–Ø –®–ê–ë–õ–û–ù
				for(uint8_t j = 0; j < strlen((const char *)&but_template);j++){

					// –ï–°–õ–? –°–?–ú–í–û–õ –®–ê–ë–õ–û–ù–ê 'B', –ó–ê–ü–?–°–´–í–ê–ï–ú –°–û–°–¢–û–Ø–ù–?–ï –ö–ù–û–ü–ö–û –ü–†–û–ö–£–†–£–¢–ö–? –? –§–õ–≠–®
					if(but_template[j] == (uint8_t)'B'){
						datastring[i].buf[j] = but_template[j];
						datastring[i].buf[j+1] = but_buf[RB_count] + 48;		// + 48 - –ü–ï–†–ï–í–û–î–?–¢ –°–?–ú–í–û–õ –?–ó INT –í CHAR
						RB_count++;
					}
					// –ï–°–õ–? –ù–ê–•–û–î–?–ú –ö–û–ú–ë–?–ù–ê–¶–?–Æ "PB", –ó–ê–ü–?–°–´–í–ê–ï–ú –°–û–°–¢–û–Ø–ù–?–ï –ö–ù–û–ü–ö–? –í–´–ö–õ–Æ–ß–ï–ù–?–Ø
					if(but_template[j] == (uint8_t)'P' && but_template[j+1] == (uint8_t)'B'){
						datastring[i].buf[j] = but_template[j];
						datastring[i].buf[j+1] = but_template[j+1];
						datastring[i].buf[j+2] = but_buf[3] + 48;		// + 48 - –ü–ï–†–ï–í–û–î–?–¢ –°–?–ú–í–û–õ –?–ó INT –í CHAR
//						RB_count++;
					}
				}
				break;

		/*- - - - - - - - –°—Ç—Ä–æ–∫–∞_‚Ññ4_(–¢–ï–ú–ü–ï–†–ê–¢–£–†–ê) - - - - - - -*/
			case ctrl_string_4:

				// –°–¢–ê–¢–£–° –°–¢–†–û–ö–? = 1 - (–¢–û–õ–¨–ö–û –î–õ–Ø –û–¢–õ–ê–î–ö–?)
				datastring[i].status = 1;
				adc_count = 0;
				adc_str_count = 0;

				// –°–ß–?–¢–´–í–ê–ï–ú –ü–û–ö–ê –ß–¢–û –î–í–ê –ö–ê–ù–ê–õ–ê –ê–¶–ü
				while(adc_count < 5){

					// –ó–ê–ü–?–°–´–í–ê–ï–ú –ó–ù–ê–ö –¢–ï–ú–ü–ï–†–ê–¢–£–†–´
					datastring[i].buf[adc_str_count] = (uint8_t)'T';

					adc_str_count++;

					// –ï–°–õ–? –û–ü–†–ê–®–?–í–ê–ï–ú –î–ê–¢–ß–?–ö –¢–ï–ú–ü–ï–†–ê–¢–£–†–´ STM, –°–ß–?–¢–ê–ï–ú –ï–ì–û –ü–û –°–ü–ï–¶–?–ê–õ–¨–ù–û–ô
					// –? –ü–ï–†–ï–í–û–î–?–ú –í –°–¢–†–û–ö–£
					// –?–ù–ê–ß–ï –ü–†–û–°–¢–û –í–´–í–û–î–?–ú –ó–ù–ê–ß–ï–ù–?–ï –¢–ï–ú–ü–ï–†–ê–¢–£–†–´
					if(!adc_count){
						itoa(TemperatureGetData(ADC_val[0]),(char *)&ADC_char,10);
					}
					else itoa(ADC_val[adc_count],(char *)&ADC_char,10);

					// –ó–ê–ü–?–°–´–í–ê–ï–ú –°–¢–†–û–ö–£ –ó–ù–ê–ß–ï–ù–?–Ø –ê–¶–ü/–¢–ï–ú–ü–ï–†–ê–¢–£–†–´ –í –°–¢–†–û–ö–£
					for(uint8_t j = 0; j < strlen((const char*)&ADC_char); j++){
						datastring[i].buf[adc_str_count] = ADC_char[j];
						adc_str_count++;
					}
					adc_count++;
				}
				break;

			/*- - - - - - - - - –°—Ç—Ä–æ–∫–∞_‚Ññ5_(–û–ü–¢–û–ü–ê–†–´) - - - - - - - -*/
				case ctrl_string_5:

					adc_count = 0;
					adc_str_count = 0;

					while(adc_str_count < 6){
						datastring[i].buf[adc_count] = (uint8_t)'O';
						adc_count++;
						datastring[i].buf[adc_count] = opt_buf[adc_str_count] + 48;
						adc_count++;
						adc_str_count++;
					}
					break;
			/*- - - - - - - - - –°—Ç—Ä–æ–∫–∞_‚Ññ6_(UP_time) - - - - - - - -*/
				case ctrl_string_6:
					adc_count = 0;
					datastring[i].buf[adc_count] = (uint8_t)'U';
					adc_count++;
					datastring[i].buf[adc_count] = (uint8_t)'P';
					adc_count++;
					datastring[i].buf[adc_count] = (uint8_t)'T';
					adc_count++;

					itoa(uptime_tick,up_time_char,10);

					for(uint8_t j = 0; j < strlen(up_time_char); j++){
						datastring[i].buf[adc_count] = up_time_char[j];
						adc_count++;
					}
			}
		}

/*-------------------- –°–û–ë–?–†–ê–ï–ú –ú–ê–°–°–?–í –î–õ–Ø –û–¢–ü–†–ê–í–ö–? ----------------------*/
		sB_pointer = 0;

		// –í–ù–ê–ß–ê–õ–ï –ë–õ–û–ö –ö–û–î–ê –ü–ï–†–ï–î –¶–?–ö–õ–û–ú –ó–ê–ü–?–°–´–í–ê–ï–¢ –°–¢–ê–†–û–¢–û–í–£–Æ –ö–û–ú–ë–?–ù–ê–¶–?–Æ –í –û–¢–ü–†–ê–í–õ–Ø–ï–ú–´–ô –ë–£–§–ï–†
		sendBuf[sB_pointer] = 'P';
		sB_pointer++;
		sendBuf[sB_pointer] = 'S';
		sB_pointer++;
		sendBuf[sB_pointer] = 'D';
		sB_pointer++;
		sendBuf[sB_pointer] = ';';
		sB_pointer++;

		crc_count = 0;

		// –¶–?–ö–õ–´ –ó–ê–ü–?–°–´–í–ê–ï–¢ –ö–ê–ñ–î–£–Æ –°–¢–†–û–ö–£ –ö–û–ù–¢–†–û–õ–Ø –í –ú–ê–°–°–?–í –? –ü–†–?–°–í–ê–ï–í–ê–ï–¢ –°–¢–†–û–ö–ï –ù–û–í–´–ô –ù–û–ú–ï–†
		for(uint8_t i = start_ctrl_string; i < start_serv_string; i++){
			sB_counter = 0;

			// –ó–ê–ü–?–°–´–í–ê–ï–ú –ù–û–ú–ï–†, –¢.–ö –°–û–°–¢–û–?–¢ –?–ó 2-–• –¶–?–§–†, –ê –í –ú–û–ï–ú –°–õ–£–ß–ê–ï
			// –?–°–ü–û–õ–¨–ó–£–Æ–¢–°–Ø –û–î–ù–û–ó–ù–ê–ß–ù–´–ï –ß–?–°–õ–ê, –ó–ê–ü–?–°–´–í–ê–ï–ú –ü–ï–†–í–´–ú 0
			sendBuf[sB_pointer] = '0';

			// –≠–¢–û–¢ –°–ß–ï–¢–ß–?–ö –û–¢–°–ß–?–¢–´–í–ê–ï–¢ –ö–û–õ–?–ß–ï–°–¢–í–û –°–?–ú–í–û–õ–û–í –î–õ–Ø –†–ê–°–ß–ï–¢–ê CRC
			crc_count++;


			sB_pointer++;

			// –ó–ê–ü–?–°–´–í–ê–ï–ú –ù–û–ú–ï–† –°–¢–†–û–ö–?, –ù–ê–ß–?–ù–ê–ï–¢–°–Ø –° 1 –? –î–û 4
			sendBuf[sB_pointer] = (i - start_ctrl_string + 1) + 48; 		// + 48 - –ü–ï–†–ï–í–û–î–?–¢ –?–ó INT –í CHAR
			crc_count++;
			sB_pointer++;

			// –ü–û–°–õ–ï –ù–û–ú–ï–†–ê –°–¢–†–û–ö–? –ó–ê–ü–?–®–ï–ú ';'
			sendBuf[sB_pointer] = ';';
			crc_count++;
			sB_pointer++;

			// –í –î–ê–ù–ù–û–ú –¶–?–ö–õ–ï –ó–ê–ü–?–°–´–í–ê–ï–¢–°–Ø –°–û–î–ï–†–ñ–?–ú–û–ï –°–¢–†–û–ö–?, –ü–û–ö–ê –°–¢–†–û–ö–ê –ù–ï –ó–ê–ö–û–ù–ß–?–¢–°–Ø
			while(datastring[i].buf[sB_counter] != '\0'){
				sendBuf[sB_pointer] = datastring[i].buf[sB_counter];
				crc_count++;
				sB_counter++;
				sB_pointer++;
			}

			// –û–¢–î–ï–õ–Ø–ï–ú –°–¢–†–ö–û–£ –ó–ù–ê–ö–û–ú ';'
			sendBuf[sB_pointer] = ';';
			crc_count++;
			sB_pointer++;
		}

		// –ö–û–ì–î–ê –í–°–ï –°–¢–†–û–ö–? –ü–ï–†–ï–ü–?–°–ê–ù–´, –ü–û–°–õ–ï –ù–?–• –ó–ê–ü–?–°–´–í–ê–ï–ú –°–¢–†–û–ö–£ "CRC"
		sendBuf[sB_pointer] = 'C';
		sB_pointer++;
		sendBuf[sB_pointer] = 'R';
		sB_pointer++;
		sendBuf[sB_pointer] = 'C';
		sB_pointer++;
		sendBuf[sB_pointer] = ';';
		sB_pointer++;

		// –†–ê–°–ß–?–¢–´–í–ê–ï–ú CRC32
		// *–ø—Ä–∏–º–µ—á–∞–Ω–∏–µ_–î–õ–Ø –†–ê–°–ß–ï–¢–ê CRC32 –í –î–ê–ù–ù–û–ú –°–õ–£–ß–ê–ï –ù–ï –?–°–ü–û–õ–¨–ó–£–ï–¢–°–Ø –û–¢–î–ï–õ–¨–ù–´–ô –ë–£–§–ï–†
		// 	–î–ê–ù–ù–´–ï –ë–ï–†–£–¢–°–Ø –?–ó –û–¢–ü–†–ê–í–õ–Ø–ï–ú–û–ì–û –ë–£–§–ï–†–ê, –ù–û –ù–ï –°–ù–ê–ß–ê–õ–ê, –ê –ü–†–û–ü–£–°–ö–ê–Ø 4 –°–?–ú–í–û–õ–ê "PSD;"
		//	–? –ó–ê–ö–ê–ù–ß–?–í–ê–Ø –î–û "–°RC", –¢.–ö –?–°–ü–û–õ–¨–ó–£–ï–¢–°–Ø –°–ß–ï–¢–ß–?–ö –°–?–ú–í–û–õ–û–í crc_count
		crc32 = Crc32((const unsigned char *) &sendBuf + 4, crc_count);

		// –ü–ï–†–ï–í–û–î–?–ú –ó–ù–ê–ß–ï–ù–?–ï –°RC32 –í –°–¢–†–û–ö–£ (–í HEX)
		itoa(crc32, (char *) &crc_hex_buf, 16);

		// –ó–ê–ü–?–°–´–í–ê–ï–ú –ü–û–°–?–ú–í–û–õ–¨–ù–û –°–¢–†–û–ö–û–í–û–ï –ó–ù–ê–ß–ï–ù–?–ï CRC32
		for(uint8_t i = 0; i < strlen((const char *) &crc_hex_buf); i++){

			// –¢.–ö itoa –ü–ï–†–ï–í–û–î–?–¢ –í HEX –?–°–ü–û–õ–¨–ó–£–Ø –ú–ê–õ–ï–ù–¨–ö–?–ï –ë–£–ö–í–´, –ú–ï–ù–Ø–ï–ú –?–• –ù–ê –ë–û–õ–¨–®–?–ï. —Å–º_–§–£–ù–ö–£–Æ BigLatter()
			sendBuf[sB_pointer] = BigLatter(crc_hex_buf[i]);
			sB_pointer++;
		}

		// –ó–ê–í–ï–†–®–ê–ï–ú –ü–ê–ö–ï–¢ ';'
		sendBuf[sB_pointer] = ';';
		sB_pointer++;

		// –û–¢–ü–†–ê–í–õ–Ø–ï–ú –ü–ê–ö–ï–¢
		if(HAL_GetTick() - transmit_timer > transmit_time){
			transmit_timer = HAL_GetTick();
			HAL_UART_Transmit(&huart3,(uint8_t *) &sendBuf, sB_pointer, 0xFFFF); // –û–¢–ü–†–ê–í–õ–Ø–ï–ú –ú–ê–°–°–?–í
		}

		if(HAL_GetTick() - transmit_timer > transmit_time * 3){
			flash_on = 0;
		}

/*------------ –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –ö–ù–û–ü–ö–? –í–´–ö–õ–Æ–ß–ï–ù–?–Ø –? –ó–ê–ü–?–°–? FLASH --------------*/
		if(but_buf[3] && (HAL_GetTick() - power_butthold > OFF_delay)){
			PowerOFF(&active.DISP);												// –ö–ù–û–ü–ö–ê –í–´–ö–õ–Æ–ß–ï–ù–?–Ø
		}

		if(but_buf[2]) FlashWriteStart();										// –ö–ù–û–ü–ö–ê –§–õ–≠–® (–ü–û–ö–ê –ù–ï –ì–û–¢–û–í)

		osDelay(50);
	}
  /* USER CODE END StartControlTask */
}

/* USER CODE BEGIN Header_StartLEDsTask */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 														   *
 *				 	  –ó–ê–î–ê–ß–ê –°–í–ï–¢–û–î–?–û–î–û–í		  		   *
 *														   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* USER CODE END Header_StartLEDsTask */
void StartLEDsTask(void const * argument)
{
  /* USER CODE BEGIN StartLEDsTask */
	RGB_status RGB[3];											// RGB –ù–ê –õ–?–¶–ï–í–û–ô –ü–ê–ù–ï–õ–?

	// –£–°–¢–ê–ù–ê–í–õ–?–í–ê–ï–ú –ü–?–ù–´ –? –ü–û–†–¢–´ –°–í–ï–¢–û–î–?–û–î–û–í
	//    *–?–°–ü–û–õ–¨–ó–£–ï–¢–°–Ø –ù–ï const, –ß–¢–û –ù–ï –ï–°–¢–¨ –•–û–†–û–®–û, –ù–û –ü–†–û–ë–õ–ï–ú –ë–´–¢–¨ –ù–ï –î–û–õ–ñ–ù–û
	RGB[0].RED.LED_port = RED_232_GPIO_Port;
	RGB[0].RED.LED_pin = RED_232_Pin;
	RGB[0].GREEN.LED_port = GREEN_232_GPIO_Port;
	RGB[0].GREEN.LED_pin = GREEN_232_Pin;
	RGB[0].BLUE.LED_port = BLUE_232_GPIO_Port;
	RGB[0].BLUE.LED_pin = BLUE_232_Pin;

	RGB[1].RED.LED_port = RED_422_GPIO_Port;
	RGB[1].RED.LED_pin = RED_422_Pin;
	RGB[1].GREEN.LED_port = GREEN_422_GPIO_Port;
	RGB[1].GREEN.LED_pin = GREEN_422_Pin;
	RGB[1].BLUE.LED_port = BLUE_422_GPIO_Port;
	RGB[1].BLUE.LED_pin = BLUE_422_Pin;

	RGB[2].RED.LED_port = RED_485_GPIO_Port;
	RGB[2].RED.LED_pin = RED_485_Pin;
	RGB[2].GREEN.LED_port = GREEN_485_GPIO_Port;
	RGB[2].GREEN.LED_pin = GREEN_485_Pin;
	RGB[2].BLUE.LED_port = BLUE_485_GPIO_Port;
	RGB[2].BLUE.LED_pin = BLUE_485_Pin;

	// –£–ö–ê–ó–ê–¢–ï–õ–¨ –ù–ê –û–¢–î–ï–õ–¨–ù–´–ô –°–í–ï–¢–û–î–?–û–î –° –ï–ì–û –î–ê–ù–ù–´–ú–? (–†–ï–ñ–?–ú–û–ú –ú–?–ì–ê–ù–?–Ø, –ü–?–ù–û–ú)
	led_status *oneLED;

	// –ó–ê–î–ï–†–ñ–ö–ê –ü–†–? –í–ö–õ–Æ–ß–ï–ù–?–? –ü–û–ö–ê –?–ù–?–¶–?–ê–õ–?–ó–?–†–£–ï–¢–°–Ø –î–?–°–ü–õ–ï–ô
	osDelay(500);

	for(;;)
	{
		// –ü–ê–†–°–?–ú –°–¢–†–û–ö–£ –°–í–ï–¢–û–î–?–û–î–û–í
		LEDStringPars((string_t *)&datastring,(RGB_status *) &RGB);



		// –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –ö–ê–ñ–î–´–ô RGB (3)
		for(uint8_t i = 0; i < 3; i++){

			// –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –ö–ê–ñ–î–´–ô –°–í–ï–¢–û–î–?–û–î –í RGB
			for(uint8_t j = 0; j < 3; j++){

				// –í–´–ë–?–†–ê–ï–ú –°–í–ï–¢–û–î–?–û–î –£–ö–ê–ó–´–í–ê–Ø –ù–ê –ù–£–ñ–ù–´–ô
				switch (j){
				case 0: oneLED = &RGB[i].RED;   break;
				case 1: oneLED = &RGB[i].BLUE;  break;
				case 2: oneLED = &RGB[i].GREEN; break;
				}

				// –£–°–¢–ê–ù–ê–í–õ–?–í–ê–ï–ú –†–ï–ñ–?–ú –ú–?–ì–ê–ù–?–Ø –°–í–ï–¢–û–î–?–û–î–û–ú
				//    *–?–°–ü–û–õ–¨–ó–£–ï–¢ uint32_t –î–õ–Ø –•–†–ê–ù–ï–ù–?–Ø –ü–ï–†–ï–ú–ï–ù–ù–û–ô –í–†–ï–ú–ï–ù–? –î–õ–Ø –ö–ê–ñ–î–û–ì–û –°–í–ï–¢–û–î–?–û–î–ê
				//     –ú–û–ñ–ï–¢ –ë–´–¢–¨ –û–ü–¢–?–ú–?–ó–?–†–û–í–ê–ù–û –ü–û –ü–ê–ú–Ø–¢–? –î–õ–Ø –ö–ê–ñ–î–û–ì–û –†–ï–ñ–?–ú–ê, –ß–¢–û –°–?–õ–¨–ù–û –£–ú–ï–ù–¨–®–?–¢ –ü–ê–ú–Ø–¢–¨
				switch (oneLED->LED_status)
				{
				case (uint8_t)'0': LED_control(oneLED,0,1); 	break;
				case (uint8_t)'1': LED_control(oneLED,1,0); 	break;
				case (uint8_t)'2': LED_control(oneLED,50,100);  break;
				case (uint8_t)'3': LED_control(oneLED,200,200); break;
				case (uint8_t)'4': LED_control(oneLED,50,500);  break;
				}
			}
		}

		osDelay(10);
	}
  /* USER CODE END StartLEDsTask */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/*
 * –û–ë–†–ê–ë–û–¢–ß–?–ö –ü–†–ï–†–´–í–ê–ù–?–ô –¢–ê–ô–ú–ï–†–ê UPTIME
 */
void UPTIME_IRQHandler(){
	uptime_tick++;
}


//void WriteToMemory_I2C(uint32_t *data){
////	HAL_I2C_Master_Transmit(&hi2c1,0b001, &i2c_go, 2, 1000);
//}
//
//uint32_t U8toU32(uint8_t *U8){
//	uint32_t U32;
//	U32 = U8[0]<<24;
//	U32 += U8[1]<<16;
//	U32 += U8[2]<<8;
//	U32 += U8[3];
//	return U32;
//}
//
//uint32_t ReadToMemory_I2C(uint8_t addres,uint8_t memry_pointer){
//	uint16_t read_mem[4];
//	HAL_I2C_Master_Transmit(&hi2c1,addres, &memry_pointer, 1, 1000);
//	HAL_I2C_Master_Receive(&hi2c1,addres, &read_mem, 4, 1000);
//
//	return U8toU32(&read_mem);
//}


/*
 * –û–ë–†–ê–ë–û–¢–ß–?–ö –ü–†–ï–†–´–í–ê–ù–?–ô ANALOG WATHDOG
 * –ü–†–? –û–¢–õ–ê–î–ö–ï –ü–õ–ê–¢–´ –ë–£–î–ï–¢ –ü–ï–†–ï–ü–?–°–ê–ù–û, –¢.–ö
 * –í –î–ê–ù–ù–û–ú –í–ê–†–?–ê–ù–¢–ï –ó–ê–¢–†–£–î–ù–ï–ù–û –û–¢–ö–õ–Æ–ß–ï–ù–?–ï –î–?–°–ü–õ–ï–Ø
 */
void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc){
	UBaseType_t uxSavedInterruptStatus;

	// –ü–†–û–í–ï–†–Ø–ï–ú –£–°–õ–û–í–?–ï, –ß–¢–û –ü–?–¢–ê–ù–?–ï 12 –í
	// –ï–°–õ–? –î–ê, –¢–û –ü–†–û–î–û–õ–ñ–ê–ï–ú
	// –ï–°–õ–? –ù–ï–¢, –¢–û –í–ö–õ–Æ–ß–ê–ï–ú –ó–£–ú–ï–†–´ –í –¶–?–ö–õ–ï
	// –ü–?–¢–ê–ù–?–ï –†–ê–°–ß–?–¢–ê–ù–û –?–ó –°–•–ï–ú–´ : 				12V/(5.1–ö + 5.1–ö + 1–ö)*1–ö = 0,29464V
	// –ü–ï–†–ï–í–û–î–?–ú –í –ó–ù–ê–ß–ï–ù–?–ï 12 –†–ê–ó–†–Ø–î–ù–û–ì–û –ê–¶–ü		0,29464*4095/3.3 = 1329,545
	// –ë–ï–†–ï–ú +-90 (+-0,8V –ù–ê –í–•–û–î)
	// –¶–?–ö–õ –ó–ê–©–?–©–ï–ù –§–£–ù–ö–¶–?–Ø–ú–? FREERTOS
	uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR ();

	while(ADC_val[4] < Low12vThreshold || ADC_val[4] > High12vThreshold){
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);

		HAL_GPIO_WritePin(STM32_Relay_mmn_GPIO_Port, STM32_Relay_mmn_Pin, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(STM32_Relay_mother_GPIO_Port, STM32_Relay_mother_Pin, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(STM32_RS_DC_DC_GPIO_Port, STM32_RS_DC_DC_Pin, GPIO_PIN_RESET);

		// –û–ë–ù–û–í–õ–Ø–ï–ú WATHDOG
		HAL_IWDG_Refresh(&hiwdg);
	}
	HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
	taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus);
}

void PowerON(u8g2_t* u8g2){
//	UBaseType_t uxSavedInterruptStatus;

	// –ü–†–û–í–ï–†–Ø–ï–ú –£–°–õ–û–í–?–ï, –ß–¢–û –ü–?–¢–ê–ù–?–ï 12 –í
	// –ï–°–õ–? –î–ê, –¢–û –ü–†–û–î–û–õ–ñ–ê–ï–ú
	// –ï–°–õ–? –ù–ï–¢, –¢–û –í–ö–õ–Æ–ß–ê–ï–ú –ó–£–ú–ï–†–´ –í –¶–?–ö–õ–ï
	// –ü–?–¢–ê–ù–?–ï –†–ê–°–ß–?–¢–ê–ù–û –?–ó –°–•–ï–ú–´ : 				12V/(5.1–ö + 5.1–ö + 1–ö)*1–ö = 1.07142V
	// –ü–ï–†–ï–í–û–î–?–ú –í –ó–ù–ê–ß–ï–ù–?–ï 12 –†–ê–ó–†–Ø–î–ù–û–ì–û –ê–¶–ü		1.07142*4095/3.3 = 1329,545
	// –ë–ï–†–ï–ú +-90 (+-0,8V –ù–ê –í–•–û–î)
	// –¶–?–ö–õ –ó–ê–©–?–©–ï–ù –§–£–ù–ö–¶–?–Ø–ú–? FREERTOS
//	uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR ();

//	while(ADC_val[4] < 1240 || ADC_val[4] > 1420){
//		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
//
//		// –û–ë–ù–û–í–õ–Ø–ï–ú WATHDOG
//		HAL_IWDG_Refresh(&hiwdg);
//	}

//	taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus);


	// –ó–ê–ñ–?–ì–ê–ï–ú –°–?–ù–?–ô –¶–í–ï–¢ RGB –ü–†–? –°–¢–ê–†–¢–ï
	HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_SET);

	// –í–ö–õ–Æ–ß–ê–ï–ú –†–ï–õ–ï
	HAL_GPIO_WritePin(STM32_Relay_mmn_GPIO_Port, STM32_Relay_mmn_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(STM32_Relay_mother_GPIO_Port, STM32_Relay_mother_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(STM32_RS_DC_DC_GPIO_Port, STM32_RS_DC_DC_Pin, GPIO_PIN_SET);

	// –í–ö–õ–Æ–ß–ê–ï–ú –ó–£–ú–ï–†–´
	for(uint8_t i = 0; i < 4; i++){
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
		osDelay(30);
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		osDelay(30);
	}

	// –ó–ê–ñ–?–ì–ê–ï–ú –î–?–°–ü–õ–ï–ô
	u8g2_DrawBox(u8g2,0,0,254,64);
	u8g2_SendBuffer(u8g2);

	// –ñ–î–ï–ú
	HAL_Delay(start_pause);

	// –¢–£–®–?–ú –î–?–°–ü–õ–ï–ô
	u8g2_ClearDisplay(u8g2);

	// –¢–£–®–?–ú –°–í–ï–¢–û–î–?–û–î–´
	HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_RESET);

	// –í–´–ö–õ–Æ–ß–ê–ï–ú –ó–£–ú–ï–†–´
	HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
}

/*
 * –§–£–ù–ö–¶–?–Ø –û–¢–ö–õ–Æ–ß–ï–ù–?–Ø –°–?–°–¢–ï–ú–´
 * –û–¢–ö–õ–Æ–ß–ê–ï–¢
 */

void PowerOFF(){

	for(uint8_t i = 0; i < 4; i++){
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
		osDelay(30);
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		osDelay(30);
	}

	display_stat = 0;

	osDelay(PowerOFF_delay);

//	vTaskDelete(myDisplayTaskHandle);

	vTaskDelete(myDataTaskHandle);
	vTaskDelete(myLEDsTaskHandle);

	HAL_GPIO_WritePin(STM32_RS_DC_DC_GPIO_Port, STM32_RS_DC_DC_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(STM32_Relay_mother_GPIO_Port, STM32_Relay_mother_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(STM32_Relay_mmn_GPIO_Port, STM32_Relay_mmn_Pin, GPIO_PIN_RESET);

	LEDs_OFF();

	SleepMode();

}

void SleepMode(){
	uint8_t switch_off = 0;
	uint8_t power_butmem = 0;									// –ü–ï–†–ï–ú–ï–ù–ù–ê–Ø –î–õ–Ø –û–¢–°–ß–ï–¢–ê –í–†–ï–ú–ï–ù–? –ù–ê–ñ–ê–¢–?–Ø –ö–ù–û–ü–ö–?
	uint32_t power_butthold = 0;
	uint16_t PWM_val = 0;
//	uint8_t direct = 1;
	double angl = 0;

	while(1){
		HAL_IWDG_Refresh(&hiwdg);

		for(uint16_t i = 0; i < 3000; i++){
			if(i < PWM_val){
				HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_SET);

				HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_SET);
			}
			else{
				HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_RESET);

				HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_RESET);
			}
		}

//		if(PWM_val < 3000 && direct){
//			PWM_val++;
//		}
//		if(PWM_val > 0 && !direct){
//			PWM_val--;
//		}
//		if(PWM_val == 0) direct = 1;
//		if(PWM_val >= 3000) direct = 0;

		angl = (angl > 3.141) ? 0 : angl + 0.004;
		PWM_val = (sin(angl)) * 1000;


		PowerButtonHandler(&power_butthold, &power_butmem, &switch_off, 500);

		while(switch_off){

		}
	}
}

void FlashWriteStart(){

}
/*
 * –§–£–ù–ö–¶–?–Ø –ü–ï–†–ï–í–û–î–?–¢ –ú–ê–õ–ï–ù–¨–ö–?–ï –ë–£–ö–í–´ –®–ï–°–¢–ù–ê–î–¶–ê–¢–?–†–?–ß–ù–û–ì–û –ù–ê–ë–û–†–ê
 * –í –ë–û–õ–¨–®–?–ï. –ï–°–õ–? –ù–ê –í–•–û–î –ü–†–?–®–õ–ê –¶–?–§–†–ê, –¢–û –í–û–ó–í–†–ê–©–ê–ï–¢–°–Ø –°–?–ú–í–û–õ –¶–?–§–†–´
 */
char BigLatter(char smalllatter){
	switch(smalllatter){
	case 'a': return 'A';
	case 'b': return 'B';
	case 'c': return 'C';
	case 'd': return 'D';
	case 'e': return 'E';
	case 'f': return 'F';
	default: return smalllatter;
	}
}

/*
 * –§–£–ù–ö–¶–?–Ø –†–ê–°–ß–ï–¢–ê –¢–ï–ú–ü–ï–†–ê–¢–£–†–´ –í–°–¢–†–û–ï–ù–û–ì–û –î–ê–¢–ß–?–ö–ê STM.
 * –ü–†–?–ù–?–ú–ê–ï–¢ –î–ê–ù–ù–´–ï –ê–¶–ü –° –¢–ï–ú–ü–ï–†–ï–ê–¢–£–†–ù–û–ì–û –ö–ê–ù–ê–õ–ê
 * –í–û–ó–í–†–ê–©–ê–ï–¢ –¢–ï–ú–ü–ï–†–ê–¢–£–†–£ –í –ì–†–ê–î–£–°–ê–• –¶–ï–õ–¨–°–?–Ø
 */
uint8_t TemperatureGetData(uint16_t ADCResult){
	int32_t temperature; /* will contain the temperature in degrees Celsius */

	temperature = (((int32_t) ADCResult * VDD_APPLI / VDD_CALIB) - (int32_t) *TEMP30_CAL_ADDR );
	temperature = temperature * (int32_t)(110 - 30);
	temperature = temperature / (int32_t)(*TEMP110_CAL_ADDR - *TEMP30_CAL_ADDR);

    return (uint8_t) temperature + 25;
}

/*
 * –ö–õ–ê–î–ï–¢ –¢–ï–ö–°–¢ –û–®–?–ë–ö–? –í 1-–Æ –°–¢–†–û–ö–£ –ö–û–ù–¢–†–û–õ–¨–ù–´–• –°–¢–†–û–ö
 */
void PutERROR(string_t *error_string, const char *error_tekst){

	// –ß–?–°–¢–?–ú –°–¢–†–û–ö–£
	for(uint8_t i = 0; i < string_size; i++){
		error_string[start_ctrl_string].buf[i] = '\0';
	}

	// –ó–ê–ü–û–õ–ù–Ø–ï–ú –°–¢–†–û–ö–£
	for(uint8_t i = 0; i < strlen(error_tekst); i++){
		error_string[start_ctrl_string].buf[i] = error_tekst[i];
	}
}

void PowerButtonHandler(uint32_t *butthold,uint8_t *butmem, uint8_t *switch_off, uint16_t off_delay){

	// –ï–°–õ–? –ö–ù–û–ü–ö–ê –ù–ê–ñ–ê–¢–ê
	if(HAL_GPIO_ReadPin(STM32_BUTTON_POWER_GPIO_Port, STM32_BUTTON_POWER_Pin)){

		HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_RESET);

		// –ï–°–õ–? –ö–ù–û–ü–ö–ê –î–û –≠–¢–û–ì–û –ù–ï –ë–´–õ–ê –ù–ê–ñ–ê–¢–ê
		if(!(*butmem &  STM32_BUTTON_POWER_Pin)){

			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

			// –ù–ê–ß–?–ù–ê–ï–¢ –û–¢–°–ß–ï–¢ –í–†–ï–ú–ï–ù–?
			*butthold = HAL_GetTick();
		}
		// –ï–°–õ–? –ü–†–û–®–õ–û –û–ü–†–ï–î–ï–õ–ï–ù–ù–û–ï –í–†–ï–ú–Ø –? –ö–ù–û–ü–ö–ê –í–°–ï –ï–©–ï –ù–ê–ñ–ê–¢–ê, –¢–û –ü–û–î–ù–?–ú–ê–ï–ú –§–õ–ê–ì
		if((HAL_GetTick() - *butthold) > off_delay){

			*switch_off = 1;

		}
	}

	*butmem = STM32_BUTTON_POWER_GPIO_Port->IDR;		// –ü–ê–ú–Ø–¢–¨ –ö–ù–û–ü–ö–?
}



/*
 * –§–£–ù–ö–¶–?–Ø –û–ë–†–ê–ë–û–¢–ö–? –ö–ù–û–ü–û–ö
 */
void ScrollingButtonHandler(uint8_t *cursor, uint32_t *butthold,uint8_t *butmem){

	// –ï–°–õ–? –ö–ù–û–ü–ö–ê –ù–ê–ñ–ê–¢–ê –? (–ù–ï –ë–´–õ–ê –ï–©–ï –ù–ê–ñ–ê–¢–ê, –?–õ–? –ü–†–û–®–õ–û –ú–ù–û–ì–û –í–†–ï–ú–ï–ù–?)
	// –£–°–õ–û–í–?–ï –†–ê–ë–û–¢–ê–ï–¢ –ù–ê –û–î–?–ù–û–ß–ù–´–ï –ù–ê–ñ–ê–¢–?–Ø, –ù–û –ï–°–õ–? –ü–†–û–®–õ–û –û–ü–†–ï–î–ï–õ–ï–ù–ù–û–ï –í–†–ï–ú–Ø,
	// –ü–ê–ú–Ø–¢–¨ –ù–ê–ñ–ê–¢–?–Ø –ö–ù–û–ü–ö–? –ù–ï –£–ß–?–¢–´–í–ê–ï–¢–°–Ø
	if(HAL_GPIO_ReadPin(STM32_BUTTON_1_GPIO_Port, STM32_BUTTON_1_Pin)){

		HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_RESET);

		if(!(*butmem & STM32_BUTTON_1_Pin) || (HAL_GetTick() - *butthold > scroll_delay)){

			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

			*cursor = (*cursor < (160 - 4)) ? *cursor + 1 : *cursor;
			osDelay(1000/scroll_speed);
			uptime = uptime_tick;
			if(!(*butmem & STM32_BUTTON_1_Pin))
				*butthold = HAL_GetTick();
		}
	}
	else {
		HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_SET);
	}

	// 2 –ê–ù–ê–õ–û–ì–?–ß–ù–û
	if(HAL_GPIO_ReadPin(STM32_BUTTON_2_GPIO_Port, STM32_BUTTON_2_Pin)){

		HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_RESET);

		if(!(*butmem & STM32_BUTTON_2_Pin) || ((HAL_GetTick() - *butthold) > scroll_delay)){

			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

			*cursor = (*cursor > 0) ? *cursor - 1 : 170;
			osDelay(1000/scroll_speed);
			uptime = uptime_tick;

			if(!(*butmem & STM32_BUTTON_2_Pin))
				*butthold = HAL_GetTick();
			}

	}
	else HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_SET);

	//3
	if(HAL_GPIO_ReadPin(STM32_BUTTON_3_GPIO_Port, STM32_BUTTON_3_Pin)){

			HAL_GPIO_WritePin(STM32_BUTTON_LED_3_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_RESET);

			if(!(*butmem & STM32_BUTTON_3_Pin) || ((HAL_GetTick() - *butthold) > scroll_delay)){

				HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
				osDelay(Button_Zummer);
				HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

				uptime = uptime_tick;
				if(!(*butmem & STM32_BUTTON_3_Pin))
					*butthold = HAL_GetTick();
				}

		}
		else HAL_GPIO_WritePin(STM32_BUTTON_LED_3_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_SET);


	*butmem = STM32_BUTTON_LED_1_GPIO_Port->IDR;						 // —Ç.–∫_–ø–æ—Ä—Ç_–∫–Ω–æ–ø–æ–∫_–æ–¥–∏–Ω
}


void ServiceModeButtonHandler(uint8_t *mem, uint8_t *mem2, uint32_t *hold, uint16_t service_delay){

	if(HAL_GPIO_ReadPin(STM32_BUTTON_1_GPIO_Port, STM32_BUTTON_1_Pin)
			&& HAL_GPIO_ReadPin(STM32_BUTTON_2_GPIO_Port, STM32_BUTTON_2_Pin)){

		// –ï–°–õ–? –ö–ù–û–ü–ö–ê –î–û –≠–¢–û–ì–û –ù–ï –ë–´–õ–ê –ù–ê–ñ–ê–¢–ê
		if(!(*mem & (STM32_BUTTON_1_Pin | STM32_BUTTON_2_Pin))){

			// –ù–ê–ß–?–ù–ê–ï–¢ –û–¢–°–ß–ï–¢ –í–†–ï–ú–ï–ù–?
			*hold = HAL_GetTick();
		}
		// –ï–°–õ–? –ü–†–û–®–õ–û –û–ü–†–ï–î–ï–õ–ï–ù–ù–û–ï –í–†–ï–ú–Ø –? –ö–ù–û–ü–ö–ê –í–°–ï –ï–©–ï –ù–ê–ñ–ê–¢–ê, –¢–û –ü–û–î–ù–?–ú–ê–ï–ú –§–õ–ê–ì
		if(((HAL_GetTick() - *hold) > service_delay) && *mem2 == 0){
			*mem2 = 1;
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(20);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
			osDelay(30);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(20);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

			service_mode = (service_mode == 0) ? 1 : 0;

			datastring[serv_string_1].status = service_mode;
			datastring[serv_string_2].status = service_mode;
			datastring[ctrl_string_1].status = service_mode;
			datastring[ctrl_string_2].status = service_mode;
			datastring[ctrl_string_3].status = service_mode;
			datastring[ctrl_string_4].status = service_mode;
			datastring[ctrl_string_5].status = service_mode;
			datastring[ctrl_string_6].status = service_mode;
		}
	}
	else{
		*mem2 = 0;
	}

	*mem = STM32_BUTTON_LED_1_GPIO_Port->IDR;
}

void ConnHandler(uint8_t *mem){

	if(HAL_GPIO_ReadPin(STM32_Conn_1_GPIO_Port, STM32_Conn_1_Pin)){

		if(!(*mem & STM32_Conn_1_Pin)){
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		}
	}

	if(!HAL_GPIO_ReadPin(STM32_Conn_1_GPIO_Port, STM32_Conn_1_Pin)){

		if((*mem & STM32_Conn_1_Pin)){
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		}
	}



	if(HAL_GPIO_ReadPin(STM32_Conn_2_GPIO_Port, STM32_Conn_2_Pin)){

		if(!(*mem & STM32_Conn_2_Pin)){
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		}
	}

	if(!HAL_GPIO_ReadPin(STM32_Conn_2_GPIO_Port, STM32_Conn_2_Pin)){

		if((*mem & STM32_Conn_2_Pin)){
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		}
	}

	*mem = STM32_Conn_1_GPIO_Port->IDR;		// –ü–ê–ú–Ø–¢–¨ –ö–ù–û–ü–ö–?
}

/*
 * –§–£–ù–ö–¶–?–Ø –†–ê–°–ß–ï–¢ CRC32. –ö–õ–ê–î–ï–¢ –í–°–ï –°–?–ú–í–û–õ–´ –ü–û–°–õ–ï "PSD;"
 * –? –î–û "CRC" –í –ú–ê–°–°–?–í crc32_buf, –ü–û–°–õ–ï –ß–ï–ì–û –°–ß–?–¢–ê–ï–¢ –ö–û–ù–¢–†–û–õ–¨–ù–£–Æ –°–£–ú–ú–£.
 * –í–û–ó–í–†–ê–©–ê–ï–¢ 1 –ï–°–õ–? –ö–û–ù–¢–†–û–õ–¨–ù–´–ï –°–£–ú–ú–´ –°–û–®–õ–?–°–¨
 * –í–û–ó–í–†–ê–©–ê–ï–¢ 0 –ï–°–õ–? –°–£–ú–ú–ê –ù–ï –°–û–®–õ–ê–°–¨ –?–õ–? –ü–ê–ö–ï–¢ –ü–û–í–†–ï–ñ–î–ï–ù
 */
uint8_t CRC32_Status(uint8_t *buf, size_t buf_size, uint16_t pointer, buffer_t *crc32_buf){

	uint8_t crc_in_buf[8];												// –°–?–ú–í–û–õ–¨–ù–´–ô –ë–£–§–ï–† –í–•–û–î–ù–û–ì–û –ó–ù–ê–ß–ï–ù–?–Ø CRC32
	uint8_t crc_string_count = 0;										// –°–ß–ï–¢–ß–?–ö
	uint32_t crc_in = 0;												// –í–•–û–î–ù–û–ï –ó–ù–ê–ß–ï–ù–?–ï CRC32
	uint32_t crc_out = 0;												// –†–ê–°–ß–?–¢–ê–ù–û–ï –ó–ù–ê–ß–ï–ù–?–ï –°RC32
	uint16_t crc_pointer = pointer;										// –£–ö–ê–ó–ê–¢–ï–õ–¨ –î–õ–Ø –ù–ê–ë–û–†–ê –ú–ê–°–°–?–í–ê CRC32

	uint16_t crc_count = string_pack_amount * string_size;				// –ú–ê–ö–°–?–ú–ê–õ–¨–ù–û–ï –ö–û–õ–?–ß–ï–°–¢–í–û –°–?–ú–í–û–õ–û–í –í –ü–ê–ö–ï–¢–ï

	// –û–ë–ù–£–õ–Ø–ï–ú –•–í–û–°–¢ –ë–£–§–ï–†–ê
	crc32_buf->tail = 0;

	// –ü–û–ö–ê –ë–£–§–ï–† –ù–ï –ó–ê–ö–û–ù–ß–?–¢–°–Ø
	while(crc_count){

		// –ï–°–õ–? –ù–ê–ô–î–ï–ù–ê –°–¢–ê–†–¢–û–í–ê–Ø –ö–û–ú–ë–?–ù–ê–¶–?–Ø, –ó–ù–ê–ß–?–¢ –ß–¢–û-–¢–û –ù–ï –¢–ê–ö
		if(FindString((uint8_t *)buf, buf_size, &crc_pointer, "PDS", 3)){
			//–º–µ—Å—Ç–æ_–¥–ª—è_–≤–∞—à–µ–π_–æ—à–∏–±–∫–∏
			return 0;
		}

		// –ï–°–õ–? –ù–ê–ô–î–ï–ù "CRC", –ó–ù–ê–ß–?–¢ –ú–ê–°–°–?–í –ù–ê–ë–†–ê–ù. –ü–†–?–°–¢–£–ü–ê–ï–ú –ö –†–ê–°–ß–ï–¢–£
		if(FindString((uint8_t *)buf, buf_size, &crc_pointer, "CRC", 3)){

			// –ü–†–û–ü–£–°–ö–ê–ï–ú ';'
			PassSym((uint8_t *)&buf, buf_size, &crc_pointer, 1);

			// –†–ê–°–ß–?–¢–´–í–ê–ï–ú CRC32 –?–ó –ú–ê–°–°–?–í–ê
			crc_out = Crc32((const unsigned char*)crc32_buf, crc32_buf->tail);
			crc_in = 0;

			if(FindString(buf, buf_size, &crc_pointer, "NAN", 3)){
				PutERROR((string_t *)&datastring,"CRC_NAN");
				return 1;
			}

			// –ü–ê–†–°–?–ú –ó–ù–ê–ß–ï–ù–?–ï CRC32 –?–ó –ü–ê–ö–ï–¢–ê
			while(buf[crc_pointer] != (uint8_t)';' && (crc_string_count < 8)){
				crc_in_buf[crc_string_count] = buf[crc_pointer];

				// –ü–ï–†–ï–í–û–î–?–ú –ü–û–õ–£–ß–ï–ù–£–Æ –°–¢–†–û–ö–£ –í DEC
				crc_in = HexToDec((char *)&crc_in_buf,8);

				// –í–´–í–û–ñ–£ –°RC –í 0-–Æ –°–¢–†–ö–û–£ –î–õ–Ø –û–¢–õ–ê–î–ö–?
				datastring[0].buf[crc_string_count] = buf[crc_pointer];

				PassSym((uint8_t *)&buf, buf_size, &crc_pointer, 1);
				crc_string_count++;
			}

			// –°–†–ê–í–ù–?–í–ê–ï–ú –ó–ù–ê–ß–ï–ù–?–Ø, –í–´–í–û–î–?–ú –°–û–û–¢–í–ï–¢–°–¢–í–£–Æ–©–ï–ï –°–û–°–¢–û–Ø–ù–?–ï CRC
			if(crc_in == crc_out){
				PutERROR((string_t *)&datastring,"CRC_OK");

				return 1;
			}
			else{
				PutERROR((string_t *)&datastring,"CRC_ERROR");
				return 0;
			}
			break;
		}
		PassSymCRC((uint8_t *)buf, buf_size, &crc_pointer, 1, crc32_buf);
		crc_count--;
	}

	// –ï–°–õ–? –ë–£–§–ï–† –ó–ê–ö–ù–û–ß–?–õ–°–Ø –? CRC –ù–ï –ë–´–õ –ù–ê–ô–î–ï–ù
	if(!crc_count){
		PutERROR((string_t *)&datastring,"CRC NOT FOUND");
		return 0;
	}
	return 0;
}

/* –§–£–ù–ö–¶–?–Ø –ü–û–?–°–ö–ê –ü–û–î–°–¢–†–û–ö–?(–ü–û–°–õ–ï–î–û–í–ê–¢–õ–¨–ù–û–°–¢–? –°–?–ú–í–û–õ–û–í) –í –?–°–•–û–î–ù–û–ú –ú–ê–°–°–?–í–ï
 * –ï–°–õ–? –ü–û–°–õ–ï–î–û–í–ê–¢–ï–õ–¨–ù–û–°–¢–¨ –û–ë–ù–ê–†–£–ñ–ï–ù–ê –í–û–ó–í–†–ê–©–ê–ï–¢ 1 –? –ó–ù–ê–ß–ï–ù–?–ï –?–ù–î–ï–ö–° pointer –ù–ê –°–õ–ï–î–£–Æ–©–?–ô
 * –°–?–ú–í–û–õ –ü–û–°–õ–ï –?–°–ö–û–ú–û–ô –°–¢–†–û–ö–?.
 * –ï–°–õ–? –ü–û–°–õ–ï–î–û–í–ê–¢–ï–õ–¨–ù–û–°–¢–¨ –ù–ï –û–ë–ù–ê–†–£–ñ–ï–ù–ê, –¢–û –í–û–ó–†–ê–©–ê–ï–¢ 0 –? –ù–ï –ú–ï–ù–Ø–ï–¢ pointer
 */
uint8_t FindString(uint8_t *buf,size_t buf_size,uint16_t *pointer,const char *str,size_t str_size){
	uint8_t count = 0;
	uint16_t p = *pointer;
	while(count < str_size){
		if(buf[p] == (uint8_t)str[count]){
			p = (p < buf_size - 1) ? p + 1 : 0;
			count++;
		}
		else return 0;
	}

	*pointer = p;
	return 1;
}

/*
 *  –§–£–ù–ö–¶–?–Ø –ú–?–ì–ê–ï–¢ –°–í–ï–¢–û–î–?–û–î–ê–ú –û–ü–?–°–ê–ù–´–ú –°–¢–†–£–ö–¢–£–†–û–ô led_status
 *  ON_time –ó–ê–î–ê–ï–¢ –í–†–ï–ú–Ø, –ö–û–¢–û–†–û–ï –°–í–ï–¢–û–î–?–û–î –í–ö–õ–Æ–ß–ï–ù
 *  OFF_time –ó–ê–î–ê–ï–¢ –í–†–ï–ú–Ø, –ö–û–¢–û–†–û–ï –°–í–ï–¢–û–î–?–î –í–´–ö–õ–Æ–ß–ï–ù
 */
void LED_control(led_status *oneLED, uint16_t ON_time, uint16_t OFF_time){

	if(OFF_time == 0 && ON_time != 0){
		HAL_GPIO_WritePin(oneLED->LED_port, oneLED->LED_pin, GPIO_PIN_SET);
		return;
	}

	if(ON_time == 0 && OFF_time != 0){
		HAL_GPIO_WritePin(oneLED->LED_port, oneLED->LED_pin, GPIO_PIN_RESET);
		return;
	}


	if(HAL_GetTick() - oneLED->timer < ON_time){
		HAL_GPIO_WritePin(oneLED->LED_port, oneLED->LED_pin, GPIO_PIN_SET);
	}
	else if(HAL_GetTick() - oneLED->timer < ON_time + OFF_time){

		HAL_GPIO_WritePin(oneLED->LED_port, oneLED->LED_pin, GPIO_PIN_RESET);
	}
	else oneLED->timer = HAL_GetTick();
}

void LEDs_OFF(){
	HAL_GPIO_WritePin(RED_232_GPIO_Port, RED_232_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GREEN_232_GPIO_Port, GREEN_232_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_RESET);

	HAL_GPIO_WritePin(RED_485_GPIO_Port, RED_485_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GREEN_485_GPIO_Port, GREEN_485_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_RESET);

	HAL_GPIO_WritePin(RED_422_GPIO_Port, RED_422_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GREEN_422_GPIO_Port, GREEN_422_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_RESET);

	HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(STM32_BUTTON_LED_3_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_RESET);
}

/*
 * –§–£–ù–ö–¶–?–Ø –ü–†–û–ü–£–°–ö–ê–ï–¢ –£–ö–ê–ó–ê–ù–û–ï –ö–û–õ–?–ß–ï–°–¢–í–û –°–?–ú–í–û–õ–û–í sym_amount
 * C –£–ß–ï–¢–û–ú –¶–?–ö–õ–?–ß–ù–û–°–¢–? –ë–£–§–ï–†–ê. –ü–†–û–ü–£–©–ï–ù–´–ï –°–?–ú–í–û–õ–´ –ù–ï –£–ß–?–¢–´–í–ê–Æ–¢–°–Ø –ü–†–? –†–ê–°–ß–ï–¢–ï CRC32
 * pointer_ - –£–ö–ê–ó–ê–¢–ï–õ–¨ –ù–ê –¢–ï–ö–£–©–?–ô –≠–õ–ï–ú–ï–ù–¢
 * sym_amount - –ö–û–õ–?–ß–ï–°–¢–í–û –ü–†–û–ü–£–°–ö–ê–ï–ú–´–• –°–?–ú–í–û–õ–û–í
 */
void PassSym(uint8_t *buf, size_t buf_size, uint16_t *pointer, uint8_t sym_amount){
	for(uint8_t i = 0; i < sym_amount; i++){
		*pointer = (*pointer < buf_size-1) ? *pointer + 1 : 0;
	}
}

/* –§–£–ù–ö–¶–?–Ø –ü–†–û–ü–£–°–ö–ê–ï–¢ –£–ö–ê–ó–ê–ù–û–ï –ö–û–õ–?–ß–ï–°–¢–í–û –°–?–ú–í–û–õ–û–í sym_amount
 * C –£–ß–ï–¢–û–ú –¶–?–ö–õ–?–ß–ù–û–°–¢–? –ë–£–§–ï–†–ê. –ü–†–û–ü–£–©–ï–ù–´–ï –°–?–ú–í–û–õ–´ –£–ß–?–¢–´–í–ê–Æ–¢–°–Ø –ü–†–? –†–ê–°–ß–ï–¢–ï CRC32*/
void PassSymCRC(uint8_t *buf,size_t buf_size,uint16_t *pointer, uint8_t sym_amount,buffer_t *crc_buf){
	for(uint8_t i = 0; i < sym_amount; i++){
		CRC32_Put(crc_buf,buf[*pointer]);
		*pointer = (*pointer < buf_size-1) ? *pointer + 1 : 0;
	}
}

/*
 * –§–£–ù–ö–¶–?–Ø –ü–ï–†–ï–í–û–î–?–¢ 16-–†–ê–ó–†–Ø–î–ù–û–ï –ß–?–°–õ–û, –ó–ê–ü–?–°–ê–ù–ù–û–ï –í –ú–ê–°–°–?–í–ï –°–?–ú–í–û–õ–û–í
 * –í 10-–†–ê–ó–†–Ø–î–ù–û–ï –?–ù–¢–û–í–û–ï –ó–ù–ê–ß–ï–ù–?–ï.
 */
uint32_t HexToDec(char *hex,uint8_t size){
	uint32_t dec = 0;

	for(uint8_t i = 0; i < size;i++){
		switch (hex[i]){
		case 'A': dec += 10 * pow(16,size-1 - i); break;
		case 'B': dec += 11 * pow(16,size-1 - i); break;
		case 'C': dec += 12 * pow(16,size-1 - i); break;
		case 'D': dec += 13 * pow(16,size-1 - i); break;
		case 'E': dec += 14 * pow(16,size-1 - i); break;
		case 'F': dec += 15 * pow(16,size-1 - i); break;

		case '1': dec += 1 * pow(16,size-1 - i); break;
		case '2': dec += 2 * pow(16,size-1 - i); break;
		case '3': dec += 3 * pow(16,size-1 - i); break;
		case '4': dec += 4 * pow(16,size-1 - i); break;
		case '5': dec += 5 * pow(16,size-1 - i); break;
		case '6': dec += 6 * pow(16,size-1 - i); break;
		case '7': dec += 7 * pow(16,size-1 - i); break;
		case '8': dec += 8 * pow(16,size-1 - i); break;
		case '9': dec += 9 * pow(16,size-1 - i); break;
		case '0': dec += 0; break;
		}
	}
	return dec;
}

/*
 * –§–£–ù–ö–¶–?–Ø –ü–ê–†–°–?–ù–ì–ê –°–¢–†–û–ö –°–í–ï–¢–û–î–?–û–î–û–í
 *
 */
void LEDStringPars(string_t *datastring, RGB_status *leds){

	// –¢.–ö. 3 RGB
	for(uint8_t i = 0; i < 3; i++){
		uint8_t pointer = 0;
		while(pointer < 6){
			switch(datastring[serv_string_1].buf[pointer]){
			case (uint8_t)'R': leds[i].RED.LED_status = datastring[serv_string_1].buf[pointer+1]; break;
			case (uint8_t)'G': leds[i].GREEN.LED_status = datastring[serv_string_1].buf[pointer+1]; break;
			case (uint8_t)'B': leds[i].BLUE.LED_status = datastring[serv_string_1].buf[pointer+1]; break;
			}
			pointer++;
		}
	}
}

/*
 * –§–£–ù–ö–¶–?–Ø –°–¢–†–û–ö–?, –£–ü–†–ê–í–õ–Ø–Æ–©–?–ï –†–ï–õ–ï, DC –? –î–°–?–ü–õ–ï–ï–ú
 */
void ServiceStringPars(string_t *datastring, ctrl_status *active){
	active->RELE[0] = (datastring[serv_string_2].buf[1] == '1') ? 1 : 0;
	active->RELE[1] = (datastring[serv_string_2].buf[3] == '1') ? 1 : 0;
	active->RELE[2] = (datastring[serv_string_2].buf[5] == '1') ? 1 : 0;
	active->RELE[3] = (datastring[serv_string_2].buf[7] == '1') ? 1 : 0;
	active->DC = datastring[serv_string_2].buf[10] - 48;
	active->DISP = datastring[serv_string_2].buf[15] - 48;
}

/*
 * –û–ë–†–ê–ë–û–¢–ß–?–ö –ü–†–ï–†–´–í–ê–ù–?–ô –ü–û–õ–û–í–?–ù–´ –ü–ï–†–ï–ü–û–õ–ù–ï–ù–?–Ø –ë–£–§–ï–†–ê uatrt_buf
 */
void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart){
	uart_hlf_flag = 1;
}

/*
 * —Ñ–£–ù–ö–¶–?–Ø –?–ù–?–¶–?–ê–õ–?–ó–ê–¶–?–? –î–?–°–ü–õ–ï–Ø
 */
void DisplayInit(u8g2_t* u8g2){
	u8g2_Setup_ssd1322_nhd_256x64_f(u8g2, U8G2_R0, u8x8_byte_4wire_hw_spi, u8x8_stm32_gpio_and_delay);
	u8g2_InitDisplay(u8g2);
	u8g2_ClearDisplay(u8g2);
	u8g2_SetPowerSave(u8g2, 0);
}
//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
//	GPIOD->ODR ^= 1<<13;
//	HAL_UART_Receive_IT(&huart3, (uint8_t*)uart_buf,UartBufSize);
//}
/* USER CODE END Application */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
