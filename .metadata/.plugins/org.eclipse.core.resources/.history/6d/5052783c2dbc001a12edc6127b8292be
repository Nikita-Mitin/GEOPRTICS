/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under Ultimate Liberty license
  * SLA0044, the "License"; You may not use this file except in compliance with
  * the License. You may obtain a copy of the License at:
  *                             www.st.com/SLA0044
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */     

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
//#define UartBufSize 40*40*10

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */





/**************************** GLOBAL VARIABLES ********************************/
uint8_t uart_buf[UartBufSize] = {'\0'};		// циклический_буфер_UART
uint8_t uart_hlf_flag = 0;					// флаг_половины_заполнения_буфера
uint8_t data_ready_flag = 0;				// флаг_готовности_данных_для_вывода (спарсен_хотяб_один_пакет)
string_t datastring[string_amount];			// массив_строк_данных - 											 											 										   общее_адрссное_пространство_для_получаемых_и_отправляемых_строк

uint16_t ADC_val[5];						// МАССИВ ХРАНИТ ЗНАЧЕНИЕ АЦП
												// 0 - СЕНСОР ТЕМПЕРАТУРЫ STM32
												// 1 - ТЕМП.СЕНСОР ПЛАТЫ 1
												// 2
												// 3
												// 4
uint8_t display_stat = 1;					// Переменная_статуса_дисплея
uint8_t LEDs_stat;							// Переменная_статуса_светодиодов
/******************************************************************************/


/* USER CODE END Variables */
osThreadId defaultTaskHandle;
osThreadId myDisplayTaskHandle;
osThreadId myDataTaskHandle;
osThreadId myControlTaskHandle;
osThreadId myLEDsTaskHandle;
osMessageQId myCursorQueueHandle;
osMessageQId myDispStatQueueHandle;
osMessageQId myDisplayStatHandle;
uint8_t myDisplayStatBuffer[ 4 * sizeof( uint8_t ) ];
osStaticMessageQDef_t myDisplayStatControlBlock;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */
   
/* USER CODE END FunctionPrototypes */

void StartDefaultTask(void const * argument);
void StartDisplayTask(void const * argument);
void StartDataTask(void const * argument);
void StartControlTask(void const * argument);
void StartLEDsTask(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];
  
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}                   
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */
       
  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the queue(s) */
  /* definition and creation of myCursorQueue */
  osMessageQDef(myCursorQueue, 5, uint8_t);
  myCursorQueueHandle = osMessageCreate(osMessageQ(myCursorQueue), NULL);

  /* definition and creation of myDispStatQueue */
  osMessageQDef(myDispStatQueue, 4, uint8_t);
  myDispStatQueueHandle = osMessageCreate(osMessageQ(myDispStatQueue), NULL);

  /* definition and creation of myDisplayStat */
  osMessageQStaticDef(myDisplayStat, 4, uint8_t, myDisplayStatBuffer, &myDisplayStatControlBlock);
  myDisplayStatHandle = osMessageCreate(osMessageQ(myDisplayStat), NULL);

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

  /* definition and creation of myDisplayTask */
  osThreadDef(myDisplayTask, StartDisplayTask, osPriorityNormal, 0, 2800);
  myDisplayTaskHandle = osThreadCreate(osThread(myDisplayTask), NULL);

  /* definition and creation of myDataTask */
  osThreadDef(myDataTask, StartDataTask, osPriorityNormal, 0, 800);
  myDataTaskHandle = osThreadCreate(osThread(myDataTask), NULL);

  /* definition and creation of myControlTask */
  osThreadDef(myControlTask, StartControlTask, osPriorityNormal, 0, 400);
  myControlTaskHandle = osThreadCreate(osThread(myControlTask), NULL);

  /* definition and creation of myLEDsTask */
  osThreadDef(myLEDsTask, StartLEDsTask, osPriorityIdle, 0, 128);
  myLEDsTaskHandle = osThreadCreate(osThread(myLEDsTask), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartDefaultTask */
/************************************************************
 * 															*
 *				 ПУСТАЯ СТАНДАРТНАЯ ЗАДАЧА					*
 *				 ВЫПОЛНЯЕТСЯ ТОГДА, КОГДА					*
 *				  НИЧЕГО НЕ ВЫПОЛНЯЕТСЯ И					*
 *				   ЗАПУСКАЕТ ПЕРЕФЕРИЮ						*
 *				   											*
 ************************************************************/
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
  /* USER CODE BEGIN StartDefaultTask */

/*------------------------- ЗАПУСКАЕМ ПЕРЕФЕРИЮ ---------------------------*/
	HAL_UART_Receive_DMA(&huart3, (uint8_t*)uart_buf, UartBufSize);	// ЗАПУСК UART В РЕЖИМЕ DMA
	HAL_IWDG_Init(&hiwdg);											// ЗАПУСК WATHDOG
	HAL_TIM_Base_Start_IT(&htim7);									// ЗАПУСК ТАЙМЕРА UP_TIME
	HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_val, 5);				// ЗАПУСК АЦП В РЕЖИМЕ DMA
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
  }
  /* USER CODE END StartDefaultTask */
}

/* USER CODE BEGIN Header_StartDisplayTask */
/*
 * ЗАДАЧА РИСОВАНИЯ НА ДИСПЛЕЙ
 * ОТБИРАЕТ СТРОКИ ДЛЯ ВЫВОДА
 * ПРИНИМАЕТ ЗНАЧЕНИЕ КУРСОРА
 * ВЫВОДИТ СТРОКИ НА ДИСПЛЕЙ
 *
 */
/************************************************************
 * 															*
 *				    ЗАДАЧА РИСОВАНИЯ НА ДИСПЛЕЙ			*
 *				    ОТБИРАЕТ СТРОКИ ДЛЯ ВЫВОДА				*
 *				  	ПРИНИМАЕТ ЗНАЧЕНИЕ КУРСОРА				*
 *				   	ВЫВОДИТ СТРОКИ НА ДИСПЛЕЙ				*
 *				   											*
 ************************************************************/
/* USER CODE END Header_StartDisplayTask */
void StartDisplayTask(void const * argument)
{
  /* USER CODE BEGIN StartDisplayTask */

/************************** ПЕРЕМЕННЫЕ ЗАДАЧИ ****************************/

/*-----------------------  ОСНОВНЫЕ ПЕРЕМЕННЫЕ ------------------------- */
	static u8g2_t u8g2;											// TypeDef_библиотеки_u8g2_для_рисования_на_дисплей
	uint16_t cursor = 0;										// Положение_окошка_дисплея
	string_t *rdy[string_amount];								// Массив_указателей_на_готовые_к_выводу_строки
//	uint8_t disp_stat = 1;										// Статус_дисплея. Определяется_приянтым_от_компа_значением
	uint8_t show_pointer = 0;

/*----------------------------- СЧЕТЧИКИ ------------------------------- */
	uint8_t rdy_count = 0;
	uint8_t show_count = 0;
	uint32_t displayOFF_del = 0;
/*----------------------- ФУНКЦИИ ИНИЦАЛИЗАЦИИ --------------------------*/
	DisplayInit(&u8g2);											// ИНИЦИАЛИЗАЦИЯ ДИСПЛЕЯ
	PowerON(&u8g2);

/***************************** ТЕЛО ЗАДАЧИ *******************************/
	for(;;){

		// УСЛОВИЕ ОПРЕДЕЛЯЮЩЕЕ, ГОТОВЫ ЛИ ДАННЫЕ ДЛЯ ВЫВОДА
		// ЕСЛИ НЕ ГОТОВЫ, ВЫВОДИТ ОКНО ЗАГРУЗКИ,
		// ИНАЧЕ ВЫПОЛНЯЕТ ВЫВОД ДАННЫХ НА ДИСПЛЕЙ
		if(!(data_ready_flag && uart_hlf_flag) && display_stat){
			display_stat = 3;
		}
		else if (display_stat){

			display_stat = (display_stat == 0) ? 0 : 1;

/*----------------------- ОТБИРАЕМ НУЖНЫЕ СТРОКИ -------------------------*/

			// ПРОСМАТРИЕВАЕМ ВЕСЬ МАССИВ СТРОК В ПОИСКАХ ГОТОВЫХ СТРОК
			// ЕСЛИ СТРОКА ГОТОВА, В МАССИВ УКАЗАТЕЛЕЙ ЗАПИСЫВАЕМ АДРЕСС ГОТОВОЙ СТРОКИ
			rdy_count = 0;
			for(uint8_t i = 1; i < start_ctrl_string; i++){
				if(datastring[i].status){
					rdy[rdy_count] = &datastring[i];
					rdy_count++;
				}
			}

/*-------------------ОПРЕДЕЛЯЕМ ПОЛОЖЕНИЕ ОКНА(КУРСОРА) ------------------*/

			// ПРИНИМАЕМ ЗНАЧЕНИЕ КУРСОРА ИЗ ЗАДАЧИ StartControlTask
			xQueueReceive(myCursorQueueHandle, &cursor, 10);

			// ПРОВЕРЯЕМ, ЧТО ОКНО НЕ ВЫХОДИТ ЗА КОНЕЦ ВЫВОДИМЫХ СТРОК(т.к_количество_строк_может_меняться)
			// ЕСЛИ ВЫХОДИТ, ТО ПРИНИМАЕМ МАКСИМАЛЬНОЕ И ОТПРАВЛЯЕМ ЗНАЧЕНИЕ ЗАДАЧЕ StartControlTask
			if(cursor > rdy_count - 1 && cursor < 160){
				cursor = 0;
				xQueueSendToBack(myCursorQueueHandle, &cursor, portMAX_DELAY);
			}
			else if(cursor > 160) {
				cursor = rdy_count-1;
				xQueueSendToBack(myCursorQueueHandle, &cursor, portMAX_DELAY);
			}

/*-------------------------- РИСУЕМ НА ДИСПЛЕЙ --------------------------*/

			// ПРИНИМАЕМ СТАТУС ДИСПЛЕЯ ИЗ ЗАДАЧИ StartControlTask
//			taskENTER_CRITICAL();
//			xQueueReceive(myDispStatQueueHandle, &display_stat, 100);
//			taskEXIT_CRITICAL();

			u8g2_ClearBuffer(&u8g2);										// ОЧИЩАЕМ БУФЕР ДИСПЛЕЯ

			u8g2_SetFont(&u8g2, u8g2_font_unifont_t_cyrillic);				// УСТАНАВЛИВАЕМ КИРИЛИЧЕСКИЙ ШРИФТ

			// ВВОДИМ В БУФЕР ДИСПЛЕЯ 4 СТРОКИ, НАЧИНАЯ С НАЧАЛА ПОЛОЖЕНИЯ КУРСОРА
//			for(uint8_t i = cursor; i < cursor + 4; i++){
//				if(i > rdy_count) i = 0;
//				u8g2_DrawUTF8(&u8g2, 0, 15+ 15 * (i - cursor),(char *) rdy[i]->buf);
//
//				// ВВОДИМ В БУФЕР ДИСПЛЕЯ ЗНАКИ СИМВОЛОВ ГРАДУСА СТРОКИ В МЕСТА, НА КОТОРЫХ ОНИ РАСПОЛОЖЕНЫ
//				for(uint8_t j = 0; j < degree_sym_amount; j++){
//					if(rdy[i]->degreeSym[j] != '\0')
//					DrawSym(&u8g2, rdy[i]->degreeSym[j] * 7 + 7, 15 + 15 * (i - cursor), 176);
//				}
//			}

			show_count = 4;
			show_pointer = cursor;

			while(show_count){

				u8g2_DrawUTF8(&u8g2, 0, 15+ 15 * (4 - show_count),(char *) rdy[show_pointer]->buf);

				// ВВОДИМ В БУФЕР ДИСПЛЕЯ ЗНАКИ СИМВОЛОВ ГРАДУСА СТРОКИ В МЕСТА, НА КОТОРЫХ ОНИ РАСПОЛОЖЕНЫ
				for(uint8_t j = 0; j < degree_sym_amount; j++){
					if(rdy[show_pointer]->degreeSym[j] != '\0')
					DrawSym(&u8g2, rdy[show_pointer]->degreeSym[j] * 7 + 7, 15 + 15 * (4 - show_count), 176);
				}

				show_pointer = (show_pointer <= rdy_count - 2) ? show_pointer + 1 : 0;
				show_count--;
			}
		}
//			// ОТПРАВЛЯЕМ БУФЕР БЕЗ РЕЖИМОВ (ДЛЯ ОТЛАДКИ)
//			u8g2_SendBuffer(&u8g2);

//			 ВЫБИРАЕМ, ЧТО ДЕЛАТЬ С ВВЕДЕННЫМИ ДАННЫМИ, ОСНОВЫВАЯСЬ НА СТАТУСЕ ДИСПЛЕЯ
//			 0 - НА ДИСПЛЕЙ НИЧЕГО НЕ ВЫВОДИТСЯ
//			 1 - ДИСПЛЕЙ РАБОТАЕТ В НОРМАЛЬНОМ РЕЖИМЕ, И ЗАСЫПАЕТ ПОСЛЕ UP_TIME(РЕДКО)
//			 2 - ДИСПЛЕЙ РАБОТАЕТ В РЕЖИМЕ СНА И ЗАСЫПАЕТ ПОСЛЕ UP_TIME_small(ЧАСТО)

		switch (display_stat){
		case 0:
			displayOFF_del = HAL_GetTick();

			while(HAL_GetTick() - displayOFF_del < PowerOFF_delay - 10){
				u8g2_ClearDisplay(&u8g2);
				OFF_Window(&u8g2);
			}
			u8g2_ClearDisplay(&u8g2);
			vTaskDelete(myDisplayTaskHandle);
			break;
		case 1:
			if(uptime_tick - uptime < UP_TIME){
				u8g2_SendBuffer(&u8g2);
			}
			else{
				u8g2_ClearDisplay(&u8g2);
			}
			break;
		case 2:
			if(uptime_tick - uptime < UP_TIME_small){
				u8g2_SendBuffer(&u8g2);
			}
			else{
				u8g2_ClearDisplay(&u8g2);
			}
			break;
		case 3:
			u8g2_ClearBuffer(&u8g2);
			LoadWindow(&u8g2, logo_width, logo_height,(uint8_t *) &logo_bits);
			u8g2_SendBuffer(&u8g2);
		}

		// ПЕРЕВОДИМ ЗАДАЧУ В РЕЖИМ ОЖИДАНИЯ (мс)
		osDelay(10);
	}
  /* USER CODE END StartDisplayTask */
}

/* USER CODE BEGIN Header_StartDataTask */
/************************************************************
 * 															*
 * 				 ЗАДАЧА ПАРСЕРА ПАКЕТОВ UART				*
 *		ПАРСИТ СТРОКИ В МАССИВ string_t datastring[]		*
 *					ИНДЕКС - НОМЕР СТРОКИ					*
 *				ПРОВЕРЯЕТ ПАКЕТ НА ЦЕЛОСТНОСТЬ				*
 *															*
*************************************************************/
/* USER CODE END Header_StartDataTask */
void StartDataTask(void const * argument)
{
  /* USER CODE BEGIN StartDataTask */

/************************** ПЕРЕМЕННЫЕ ЗАДАЧИ ****************************/

		/*- - - - - - - -  ОСНОВНЫЕ ПЕРЕМЕННЫЕ - - - - - - - - - */
	uint16_t stringnum = 0;										// ХРАНИТ НОМЕР ТЕКУЩЕЙ СТРОКИ
	buffer_t crc32_buf;											// БУФЕР, В КОТОРЫЙ ЗАПИСЫВАЮТСЯ ДАННЫЕ ДЛЯ РАСЧЕТА СRC32
	char strnumhex[2];											// СИМВОЛЬНЫЙ БУФЕР, ХРАНЯЩИЙ НОМЕР СТРОКИ в hex

		/*- - - - - - - - - - - СЧЕТЧИКИ  - - - - - - - - - - - -*/
	uint16_t counter = 0;										// СЧЕТЧИК ЦИКЛИЧЕСКОГО БУФЕРА (АТАВИЗМ)
	uint16_t pointer = 0;										// УКАЗАТЕЛЬ НА СИМВОЛ БУФЕРА uart_buf
	uint8_t celsium_count = 0;									// СЧЕТЧИК ДЛЯ ЗАПОЛНЕНИЯ ЗНАКОВ ГРАДУСА ЦЕЛЬСИЯ
	uint8_t string_count = 0;									// СЧЕТЧИК ДЛЯ ЗАПОЛНЕНИЯ СТРОК
	uint32_t restart_val = 0;

	osDelay(500);
/***************************** ТЕЛО ЗАДАЧИ *******************************/
	for(;;){

		// ЕСЛИ rx НЕ В ПРОСТОЕ, ТО ЖДЕМ ОПРЕДЕЛЕННОЕ ВРЕМЯ
		// И НАЧИНАЕМ ПОИСК СТАРТОВОЙ КОМБИНАЦИИ
		// УСЛОВИЕ ПОМАГАЕТ ПАРСИТЬ НОВЫЙ ПАКЕТ ОДИН РАЗ
		if(!(USART3->SR & USART_SR_IDLE)){
			restart_val = HAL_GetTick();

			HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_RESET);

			osDelay(pack_DELAY);

			counter = UartBufSize;

			// ТЕЛО ПАРСЕРА:
			// ПРОБЕГАЕТ ВЕСЬ БУФЕР В ПОИСКАХ СТАРТОВОЙ КОМБИНАЦИИ
			// ПОСЛЕ ТОГО, КАК НАЙДЕТ, ОБРАБАТЫВАЕТ ПАКЕТ И ВЫХОДИТ ИЗ ТЕЛА ЦИКЛА
			while(counter){

				// ЕСЛИ НАЙДЕНА СТАРТОВАЯ КОМБИНАЦИЯ, ТО НАЧИНАЕМ ПАРСИТЬ
				if(FindString((uint8_t *)&uart_buf, UartBufSize, &pointer,"PDS", 3)){


					// ПРОПУСКАЕМ СИМВОЛ ';'
					PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 1);

					// РАСЧИТЫВАЕМ CRC32, ЕСЛИ CRC СОШЕЛСЯ, ПРОДОЛЖАЕМ ПАРСИТЬ
					// ИНАЧЕ ОСТАНАВЛИВАЕМ ПАРСИНГ: ФУНКЦИЯ ЗАПИСЫВАЕТ И ОШИБКИ CRC
//					if(CRC32_Status((uint8_t *)&uart_buf, UartBufSize, pointer, &crc32_buf)){}
//					else break;

					// ЦИКЛ ПАРСИТ string_pack_amount СТРОК ПО ОТДЕЛЬНОСТИ
					for(uint8_t i = 0; i < string_pack_amount; i++){

						// ЕСЛИ ВМЕСТО НОМЕРА СТРОКИ НАЙДЕНА КОМИНАЦИЯ CRC - ПАКЕТ ОКОНЧЕН, ВЫХОДИМ ИЗ ПАРСИНГА
						if(FindString((uint8_t *)&uart_buf, UartBufSize, &pointer, "CRC", 3)){
							break;
						}

						string_count = 0;
						celsium_count = 0;

						// НОМЕР СТРОКИ ВСЕГДА СОСТОИТ ИЗ ДВУХ СИМВОЛОВ
						// ПАРСИМ ПЕРВЫЙ СИМВОЛ И ПЕРЕХОДИМ К СЛЕДУЮЩЕМУ
						strnumhex[0] = uart_buf[pointer];
						PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 1);

						// ПАРСИМ ВТОРОЙ СИМВОЛ И ПРОПУСКАЕМ 2 СИМВОЛА: ЭТОТ И ';'
						strnumhex[1] = uart_buf[pointer];
						PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 2);

						// ПЕРЕВОДИМ СТРОКУ НОМЕРА: (char, hex) -> (int, dec)
						stringnum = HexToDec((char *) &strnumhex,2);
						datastring[stringnum].number = stringnum;

						// ПАРСИМ СОДЕРЖИМОЕ СТРОКИ:
						// ПОКА НЕ НАЙДЕМ ЗНАК ';' ИЛИ СТРОКА НЕ ЗАКОНЧИТСЯ
						// КЛАДЕМ КАЖДЫЙ СИМВОЛ СОДЕРЖИМОГО БУФЕРА НАЧИНАЯ С pointer
						// В БУФЕР СТРОКИ НАЧИНАЯ С string_count (0)
						while((uart_buf[pointer] != (uint8_t)';') && (string_count < string_size)){

							// ЕСЛИ НАЙДЕНА КОМБИНАЦИЯ DEL, ЗНАЧИТ СТРОКУ НУЖНО УДАЛИТЬ (СТАТУС СТРОКИ = 0)
							// И ПАРСИНГ СОДЕРЖИМОГО СТРОКИ ПРЕКРАЩАЕТСЯ
							// ИНАЧЕ СТАТУС СТРОКИ = 1
							if(FindString((uint8_t *)&uart_buf, UartBufSize, &pointer, "DEL", 3) && !string_count){
								datastring[stringnum].status = 0;
								break;
							}
							else if(!string_count) datastring[stringnum].status = 1;

							// ЕСЛИ НАЙДЕНА КОМБИНАЦИЯ "*C" ВМЕСТО НЕЕ КЛАДЕМ В СТРОКУ ' '
							// И ЗАПИСЫВАЕМ ПОЛОЖЕНИЕ ЗНАКА ГРАДУСА (string_count)
							if(FindString((uint8_t *)&uart_buf,UartBufSize,&pointer,"*C",2)){
								datastring[stringnum].buf[string_count] = (uint8_t)' ';
								datastring[stringnum].degreeSym[celsium_count] = string_count;
								string_count++;
								celsium_count++;
							}

							// ЕСЛИ НИ ОДНА ИЗ КОМБИНАЦИЙ НЕ БЫЛА НАЙДЕНА
							// ПРОСТО КЛАДЕМ СИМВОЛ БУФЕРА В СТРОКУ
							datastring[stringnum].buf[string_count] = uart_buf[pointer];
							PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 1);
							string_count++;
						}

						// КОГДА СТРОКА УЖЕ ЗАПОЛНЕНА ДАННЫМИ,
						// ОЧИЩАЕМ ОСТАВШИЕСЯ ЭЛЕМЕНТЫ В БУФЕРЕ СТРОКИ
						while(string_count < string_size){
							datastring[stringnum].buf[string_count] = '\0';
							string_count++;
						}
						// ПРОПУСКАЕМ ';'
						PassSym((uint8_t *)&uart_buf, UartBufSize, &pointer, 1);
					}

					// СТАВИМ ФЛАГ ГОТОВНОСТИ ДАННЫХ, ДЛЯ ВЫХОДА ИЗ ЗАГРУЗОЧНОГО ОКНА
					// И ВЫХОДИМ ИЗ ПАРСЕРА ПАКЕТА
					data_ready_flag = 1;
					break;
				}

				// ЕСЛИ PSD НЕ НАЙДЕН, ПРОПУСКАЕМ СИМВОЛ ЗА СИМВОЛОМ ПОКА БУФЕР НЕ КОНЧИТСЯ
				PassSym((uint8_t *)&uart_buf,UartBufSize,&pointer,1);
				counter--;
			}
			if(!counter){
				// ВЫВОДИМ ОШИБКУ, ЧТО СТАРТОВАЯ КОМБИНАЦИЯ НЕ БЫЛА НАЙДЕНА
				PutERROR((string_t *)&datastring,"PACK_NOT_FOUND");
			}
		}

		// ЕСЛИ ДАННЫЕ НЕ ОБНОВЛЯЮТСЯ КАКОЕ ТО ВРЕМЯ,
		// ПЕРЕЗАПУСКАЕМ UART, ДЛЯ ИЗБЕЖАНИЯ ВОЗМОЖНЫХ ОШИБОК
		if(HAL_GetTick() - restart_val > restart_time){
			HAL_UART_DMAStop(&huart3);
			HAL_UART_Receive_DMA(&huart3, (uint8_t*)uart_buf, UartBufSize);
		}

		// ОБНАВЛЯЕМ WATHDOG
		HAL_IWDG_Refresh(&hiwdg);

//		if(!HAL_GPIO_ReadPin(STM32_BUTTON_POWER_GPIO_Port, STM32_BUTTON_POWER_Pin)){
			HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_SET);
//		}
		// ПЕРЕВОДИМ ЗАДАЧУ В РЕЖИМ ОЖИДАНИЯ. ВРЕМЯ МАЛО, ЧТОБ НЕ ПРОПУСТЬ ПАКЕТ
		osDelay(10);
	}
  /* USER CODE END StartDataTask */
}

/* USER CODE BEGIN Header_StartControlTask */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 														   *
 *				 ЗАДАЧА ОБРАБОТКИ СЛУЖЕБНЫХ СТРОК		   *
 *				  И СОСТАВЛЕНИЯ СТРОК НА ОТПРАВКУ		   *
 *														   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* USER CODE END Header_StartControlTask */
void StartControlTask(void const * argument)
{
  /* USER CODE BEGIN StartControlTask */

/************************** ПЕРЕМЕННЫЕ ЗАДАЧИ ****************************/

/*-------------------- ШАБЛОНЫ ДЛЯ ЗАПОЛНЕНИЯ СТРОК ---------------------*/
	const uint8_t ctrl_template[] = "R?R?R?R?DC?";				// ШАБЛОН ДЛЯ СТРОКИ С ДАННЫМИ O РЕЛЕ И DC
	const uint8_t but_template[] = 	"B?B?B?PB?";				// ШАБЛОН ДЛЯ СТРОКИ С ДАННЫМИ СОСТОЯНИ КНОПОК

/*-------------------------- ПЕРЕМЕННЫЕ CRC32 ---------------------------*/
	uint16_t crc_count = 0;										// СЧЕТЧИК ДЛЯ ОПРЕДЕЛЕНИЯ РАЗМЕРА CRC32
	uint8_t crc_hex_buf[10];									// СИМВОЛЬНЫЙ БУФЕР, ХРАНЯЩИЙ ЗАПИСЬ CRC32 В hex
	int32_t crc32;												// ХРАНИТ РАСЧИТАНОЕ ЗНАЯЕНИЕ CRC32

/*------------------------- ПЕРЕМЕННЫЕ RELE/DC --------------------------*/
	ctrl_status active;											// ПЕРЕМЕННАЯ СТРУКТУРЫ СТРОК РЕЛЕ/DC
	uint16_t RELE_PINS[] = {STM32_OUT_REL_1_Pin, 				// МАССИВ, ХРАНЯЩИЙ НОМЕРА ПИНОВ РЕЛЕ
							STM32_OUT_REL_2_Pin, 					//
							STM32_OUT_REL_3_Pin, 					//
							STM32_OUT_REL_4_Pin};					//
	GPIO_TypeDef *RELE_PORTS[] = {STM32_OUT_REL_1_GPIO_Port, 	// МАССИВ, ХРАНЯЩИЙ НОМЕРА ПОРТОВ РЕЛЕ
								STM32_OUT_REL_2_GPIO_Port, 			//
								STM32_OUT_REL_3_GPIO_Port, 			//
								STM32_OUT_REL_4_GPIO_Port};			//
	uint8_t RB_count = 0;										// РЕЛЕ/DC СЧЕТЧИК

/*--------------------------- ФЛАГИ СОСТОЯНИЯ ---------------------------*/
	uint8_t switch_off = 0;										// ФЛАГ ВЫКЛЮЧЕНИЯ ПИТАНИЯ
	uint8_t flash_on = 0;										// ФЛАГ ЗАПИСИ В ФЛЭШ

/*--------------------------- ВСЕ ДЛЯ КНОПОК ----------------------------*/
	uint8_t but_buf[4];											// БУФЕР ХРАНИТ СОСТОЯНИЕ 4-Ч КНОПОК
																	// (0, 1 - ПРОКРУТКА; 2 - ФЛЭШ; 3 - ВЫКЛЮЧЕНИЕ)
	uint8_t cursor = 0;											// ПОЛОЖЕНИЕ КУРСОРА
	uint8_t butmem = 0;											// ПЕРЕМЕННАЯ ЗАПОМИНАЕТ СОСТОЯНИЕ КНОПОК
	uint8_t power_butmem = 0;
	uint32_t butthold = 0;										// ПЕРЕМЕННАЯ ДЛЯ ОТСЧЕТА ВРЕМЕНИ НАЖАТИЯ КНОПКИ
	uint32_t power_butthold = 0;

/*----------------------- БУФЕР НА ОТПРАВКУ UART ------------------------*/
	uint8_t sendBuf[ctrl_string_amnt*string_size] = {'\0'};		// ОТПРАВЛЯЕМЫЙ ПО UART БУФЕР
	uint16_t sB_pointer = 0;									// УКАЗАТЕЛЬ БУФЕРА
	uint8_t sB_counter = 0;										// СЧЕТЧИК БУФЕРА
	uint32_t transmit_timer = 0;								// СОХРАНЯЕТ ВРЕМЯ ПОСЛЕДНЕЙ ОТПРАВКИ

/*--------------------------- ПЕРЕМЕННЫЕ АЦП ---------------------------*/
	uint8_t ADC_char[4];										// БУФЕР ДЛЯ ПЕРЕВОДА ЗНАЧЕНИЯ АЦП В СТРОКУ
	char up_time_char[10];
	uint8_t adc_count = 0;			 							// СЧЕТЧИК АЦП
	uint8_t adc_str_count = 0;									// СЧЕТЧИК СТРОК АЦП
	uint8_t opt_buf[6] = {0};
/*-------------------------- ФУНКЦИИ ЗАПУСКА ----------------------------*/
//	HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_val,5);			// ЗАПУСК АЦП В РЕЖИМЕ DMA



	osDelay(500);
/***************************** ТЕЛО ЗАДАЧИ *******************************/
	for(;;){

/*--------------------- ОБРАБАТЫВАЕМ НАЖАТИЯ КНОПОК ---------------------*/

		// ПРИНИМАЕМ ЗНАЧЕНИЕ КУРСОР ИЗ ЗАДАЧИ StartDisplayTask
		xQueueReceive(myCursorQueueHandle,&cursor, 10);
		// ОБРАБАТЫВАЕМ КНОПКИ ПРОКРУТКИ ДИСПЛЕЯ
		ScrollingButtonHandler(&cursor, &butthold, &butmem);

		// ОТПРАВЛЯЕМ ОБНОВЛЕННОЕ ЗНАЧЕНИЕ КУРСОРА ОБРАТНО В ЗАДАЧУ StartDisplayTask
		xQueueSendToBack(myCursorQueueHandle, &cursor, 10);

		// ОБРАБАТЫВАЕМ КНОПКУ ОТКЛЮЧЕНИЯ ПИТАНИЯ
		PowerButtonHandler(&power_butthold, &power_butmem, &switch_off, OFF_delay - 1000);

/*----------- ЗАПИСЫВАЕМ СОСТОЯНИЕ КНОПОК В МАССИВ СОСТОЯНИЯ -----------*/
		but_buf[0] = butmem & STM32_BUTTON_1_Pin;						// КНОПКА ПРОКУРТКИ ВНИЗ
		but_buf[1] = butmem & STM32_BUTTON_2_Pin;						// КНОПКА ПРОКРУТКИ ВВЕРХ
		but_buf[2] = flash_on;											// КНОПКА ЗАПИСИ ВО ФЛЭШ
		but_buf[3] = switch_off;										// КНОПКА ВЫКЛЮЧЕНИЯ

		opt_buf[0] = HAL_GPIO_ReadPin(STM32_R_24_NO_GPIO_Port,STM32_R_24_NO_Pin);
		opt_buf[1] = HAL_GPIO_ReadPin(STM32_R_24_NC_GPIO_Port,STM32_R_24_NC_Pin);
		opt_buf[2] = HAL_GPIO_ReadPin(INPUT_OUTSIDE_1_GPIO_Port,INPUT_OUTSIDE_1_Pin);
		opt_buf[3] = HAL_GPIO_ReadPin(INPUT_OUTSIDE_2_GPIO_Port,INPUT_OUTSIDE_2_Pin);
		opt_buf[4] = HAL_GPIO_ReadPin(STM32_Conn_1_GPIO_Port,STM32_Conn_1_Pin);
		opt_buf[5] = HAL_GPIO_ReadPin(STM32_Conn_2_GPIO_Port,STM32_Conn_2_Pin);

/*--------------- ОБРАБОТАВАЕМ и ВЫВОДИМ СИГНАЛЫ НА ПИНЫ ---------------*/

		// ПАРСИМ СЛУЖЕБНЫЕ СТРОКИ
		ServiceStringPars((string_t *) &datastring, &active);

		// МАССИВ ЗАДАЕТ СОСТОЯНИЕ РЕЛЕ, ВЗАИВИСОСТИ ОТ ПОЛУЧЕННЫХ ДАННЫХ
		for(uint8_t i = 0; i < 4; i++){
			if(active.RELE[i])
				HAL_GPIO_WritePin(RELE_PORTS[i], RELE_PINS[i], GPIO_PIN_SET);
			else
				HAL_GPIO_WritePin(RELE_PORTS[i], RELE_PINS[i], GPIO_PIN_RESET);
		}

		// СОСТОЯНИЕ ДИСПЛЕЯ ОТПРАВЛЯЕТСЯ В ЗАДАЧУ StartDisplayTask
//		xQueueSendToBack(myDispStatQueueHandle, &active.DISP, portMAX_DELAY);

/*------------------------- СОСТАВЛЯЕМ СТРОКИ --------------------------*/

		// ПРОБЕГАЕМ ВСЕ СТРОКИ КНОТРОЛЯ (ЦИКЛ ТУТ ЛИШНИЙ, НО ПУСТЬ ПОКА БУДЕТ)
		for(uint8_t i = start_ctrl_string; i < start_serv_string; i++){
			switch (i){

		/*- - - - - - - -  Строка_№2_(РЕЛЕ/DC) - - - - - - - -*/
			case ctrl_string_2:

				RB_count = 0;

				// ЗАПОЛНЯЕМ СТРОКУ, ИСПОЛЬЗУЯ ШАБЛОН
				for(uint8_t j = 0; j < strlen((const char *)&ctrl_template);j++){

					// ЕСЛИ СИМВОЛ ШАБЛОНА 'R', ЗАПИСЫВАЕМ СОСТОЯНИЕ РЕЛЕ(RB_COUNT ПО СЧЕТУ)
					if(ctrl_template[j] == (uint8_t)'R'){
						datastring[i].buf[j] = ctrl_template[j];
						datastring[i].buf[j+1] = active.RELE[RB_count] + 48; 	// + 48 - ПЕРЕВОДИТ СИМВОЛ ИЗ INT В CHAR
						RB_count++;
					}

					// ЕСЛИ НАХОДИМ КОМБИНАЦИЮ "DC", ЗАПИСЫВАЕМ СОСТОЯНИЕ DC
					if(ctrl_template[j] == (uint8_t)'D' && ctrl_template[j+1] == (uint8_t)'C'){
						datastring[i].buf[j] = ctrl_template[j];
						datastring[i].buf[j+1] = ctrl_template[j+1];
						datastring[i].buf[j+2] = active.DC + 48;				// + 48 - ПЕРЕВОДИТ СИМВОЛ ИЗ INT В CHAR
					}
				}
				break;

		/*- - - - - - - - -  Строка_№3_(КНОПКИ) - - - - - - - -*/
			case ctrl_string_3:

				RB_count = 0;

				// ЗАПОЛНЯЕМ СТРОКУ, ИСПОЛЬЗУЯ ШАБЛОН
				for(uint8_t j = 0; j < strlen((const char *)&but_template);j++){

					// ЕСЛИ СИМВОЛ ШАБЛОНА 'B', ЗАПИСЫВАЕМ СОСТОЯНИЕ КНОПКО ПРОКУРУТКИ И ФЛЭШ
					if(but_template[j] == (uint8_t)'B'){
						datastring[i].buf[j] = but_template[j];
						datastring[i].buf[j+1] = but_buf[RB_count] + 48;		// + 48 - ПЕРЕВОДИТ СИМВОЛ ИЗ INT В CHAR
						RB_count++;
					}
					// ЕСЛИ НАХОДИМ КОМБИНАЦИЮ "PB", ЗАПИСЫВАЕМ СОСТОЯНИЕ КНОПКИ ВЫКЛЮЧЕНИЯ
					if(but_template[j] == (uint8_t)'P' && but_template[j+1] == (uint8_t)'B'){
						datastring[i].buf[j] = but_template[j];
						datastring[i].buf[j+1] = but_template[j+1];
						datastring[i].buf[j+2] = but_buf[3] + 48;		// + 48 - ПЕРЕВОДИТ СИМВОЛ ИЗ INT В CHAR
//						RB_count++;
					}
				}
				break;

		/*- - - - - - - - Строка_№4_(ТЕМПЕРАТУРА) - - - - - - -*/
			case ctrl_string_4:

				// СТАТУС СТРОКИ = 1 - (ТОЛЬКО ДЛЯ ОТЛАДКИ)
				datastring[i].status = 1;
				adc_count = 0;
				adc_str_count = 0;

				// СЧИТЫВАЕМ ПОКА ЧТО ДВА КАНАЛА АЦП
				while(adc_count < 5){

					// ЗАПИСЫВАЕМ ЗНАК ТЕМПЕРАТУРЫ
					datastring[i].buf[adc_str_count] = (uint8_t)'T';

					adc_str_count++;

					// ЕСЛИ ОПРАШИВАЕМ ДАТЧИК ТЕМПЕРАТУРЫ STM, СЧИТАЕМ ЕГО ПО СПЕЦИАЛЬНОЙ
					// И ПЕРЕВОДИМ В СТРОКУ
					// ИНАЧЕ ПРОСТО ВЫВОДИМ ЗНАЧЕНИЕ ТЕМПЕРАТУРЫ
					if(!adc_count){
						itoa(TemperatureGetData(ADC_val[0]),(char *)&ADC_char,10);
					}
					else itoa(ADC_val[adc_count],(char *)&ADC_char,10);

					// ЗАПИСЫВАЕМ СТРОКУ ЗНАЧЕНИЯ АЦП/ТЕМПЕРАТУРЫ В СТРОКУ
					for(uint8_t j = 0; j < strlen((const char*)&ADC_char); j++){
						datastring[i].buf[adc_str_count] = ADC_char[j];
						adc_str_count++;
					}
					adc_count++;
				}
				break;

			/*- - - - - - - - - Строка_№5_(ОПТОПАРЫ) - - - - - - - -*/
				case ctrl_string_5:

					adc_count = 0;
					adc_str_count = 0;

					while(adc_str_count < 6){
						datastring[i].buf[adc_count] = (uint8_t)'O';
						adc_count++;
						datastring[i].buf[adc_count] = opt_buf[adc_str_count] + 48;
						adc_count++;
						adc_str_count++;
					}
					break;
			/*- - - - - - - - - Строка_№6_(UP_time) - - - - - - - -*/
				case ctrl_string_6:
					adc_count = 0;
					datastring[i].buf[adc_count] = (uint8_t)'U';
					adc_count++;
					datastring[i].buf[adc_count] = (uint8_t)'P';
					adc_count++;
					datastring[i].buf[adc_count] = (uint8_t)'T';
					adc_count++;

					itoa(uptime_tick,up_time_char,10);

					for(uint8_t j = 0; j < strlen(up_time_char); j++){
						datastring[i].buf[adc_count] = up_time_char[j];
						adc_count++;
					}
			}
		}

/*-------------------- СОБИРАЕМ МАССИВ ДЛЯ ОТПРАВКИ ----------------------*/
		sB_pointer = 0;

		// ВНАЧАЛЕ БЛОК КОДА ПЕРЕД ЦИКЛОМ ЗАПИСЫВАЕТ СТАРОТОВУЮ КОМБИНАЦИЮ В ОТПРАВЛЯЕМЫЙ БУФЕР
		sendBuf[sB_pointer] = 'P';
		sB_pointer++;
		sendBuf[sB_pointer] = 'S';
		sB_pointer++;
		sendBuf[sB_pointer] = 'D';
		sB_pointer++;
		sendBuf[sB_pointer] = ';';
		sB_pointer++;

		crc_count = 0;

		// ЦИКЛЫ ЗАПИСЫВАЕТ КАЖДУЮ СТРОКУ КОНТРОЛЯ В МАССИВ И ПРИСВАЕВАЕТ СТРОКЕ НОВЫЙ НОМЕР
		for(uint8_t i = start_ctrl_string; i < start_serv_string; i++){
			sB_counter = 0;

			// ЗАПИСЫВАЕМ НОМЕР, Т.К СОСТОИТ ИЗ 2-Х ЦИФР, А В МОЕМ СЛУЧАЕ
			// ИСПОЛЬЗУЮТСЯ ОДНОЗНАЧНЫЕ ЧИСЛА, ЗАПИСЫВАЕМ ПЕРВЫМ 0
			sendBuf[sB_pointer] = '0';

			// ЭТОТ СЧЕТЧИК ОТСЧИТЫВАЕТ КОЛИЧЕСТВО СИМВОЛОВ ДЛЯ РАСЧЕТА CRC
			crc_count++;


			sB_pointer++;

			// ЗАПИСЫВАЕМ НОМЕР СТРОКИ, НАЧИНАЕТСЯ С 1 И ДО 4
			sendBuf[sB_pointer] = (i - start_ctrl_string + 1) + 48; 		// + 48 - ПЕРЕВОДИТ ИЗ INT В CHAR
			crc_count++;
			sB_pointer++;

			// ПОСЛЕ НОМЕРА СТРОКИ ЗАПИШЕМ ';'
			sendBuf[sB_pointer] = ';';
			crc_count++;
			sB_pointer++;

			// В ДАННОМ ЦИКЛЕ ЗАПИСЫВАЕТСЯ СОДЕРЖИМОЕ СТРОКИ, ПОКА СТРОКА НЕ ЗАКОНЧИТСЯ
			while(datastring[i].buf[sB_counter] != '\0'){
				sendBuf[sB_pointer] = datastring[i].buf[sB_counter];
				crc_count++;
				sB_counter++;
				sB_pointer++;
			}

			// ОТДЕЛЯЕМ СТРКОУ ЗНАКОМ ';'
			sendBuf[sB_pointer] = ';';
			crc_count++;
			sB_pointer++;
		}

		// КОГДА ВСЕ СТРОКИ ПЕРЕПИСАНЫ, ПОСЛЕ НИХ ЗАПИСЫВАЕМ СТРОКУ "CRC"
		sendBuf[sB_pointer] = 'C';
		sB_pointer++;
		sendBuf[sB_pointer] = 'R';
		sB_pointer++;
		sendBuf[sB_pointer] = 'C';
		sB_pointer++;
		sendBuf[sB_pointer] = ';';
		sB_pointer++;

		// РАСЧИТЫВАЕМ CRC32
		// *примечание_ДЛЯ РАСЧЕТА CRC32 В ДАННОМ СЛУЧАЕ НЕ ИСПОЛЬЗУЕТСЯ ОТДЕЛЬНЫЙ БУФЕР
		// 	ДАННЫЕ БЕРУТСЯ ИЗ ОТПРАВЛЯЕМОГО БУФЕРА, НО НЕ СНАЧАЛА, А ПРОПУСКАЯ 4 СИМВОЛА "PSD;"
		//	И ЗАКАНЧИВАЯ ДО "СRC", Т.К ИСПОЛЬЗУЕТСЯ СЧЕТЧИК СИМВОЛОВ crc_count
		crc32 = Crc32((const unsigned char *) &sendBuf + 4, crc_count);

		// ПЕРЕВОДИМ ЗНАЧЕНИЕ СRC32 В СТРОКУ (В HEX)
		itoa(crc32, (char *) &crc_hex_buf, 16);

		// ЗАПИСЫВАЕМ ПОСИМВОЛЬНО СТРОКОВОЕ ЗНАЧЕНИЕ CRC32
		for(uint8_t i = 0; i < strlen((const char *) &crc_hex_buf); i++){

			// Т.К itoa ПЕРЕВОДИТ В HEX ИСПОЛЬЗУЯ МАЛЕНЬКИЕ БУКВЫ, МЕНЯЕМ ИХ НА БОЛЬШИЕ. см_ФУНКУЮ BigLatter()
			sendBuf[sB_pointer] = BigLatter(crc_hex_buf[i]);
			sB_pointer++;
		}

		// ЗАВЕРШАЕМ ПАКЕТ ';'
		sendBuf[sB_pointer] = ';';
		sB_pointer++;

		// ОТПРАВЛЯЕМ ПАКЕТ
		if(HAL_GetTick() - transmit_timer > transmit_time){
			transmit_timer = HAL_GetTick();
			HAL_UART_Transmit(&huart3,(uint8_t *) &sendBuf, sB_pointer, 0xFFFF); // ОТПРАВЛЯЕМ МАССИВ
		}


/*------------ ОБРАБАТЫВАЕМ КНОПКИ ВЫКЛЮЧЕНИЯ И ЗАПИСИ FLASH --------------*/
//		if(but_buf[3] && (HAL_GetTick() - power_butthold > OFF_delay)){
//			PowerOFF(&active.DISP);												// КНОПКА ВЫКЛЮЧЕНИЯ
//		}

		if(but_buf[2]) FlashWriteStart();										// КНОПКА ФЛЭШ (ПОКА НЕ ГОТОВ)



		osDelay(50);
	}
  /* USER CODE END StartControlTask */
}

/* USER CODE BEGIN Header_StartLEDsTask */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 														   *
 *				 	  ЗАДАЧА СВЕТОДИОДОВ		  		   *
 *														   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* USER CODE END Header_StartLEDsTask */
void StartLEDsTask(void const * argument)
{
  /* USER CODE BEGIN StartLEDsTask */
	RGB_status RGB[3];											// RGB НА ЛИЦЕВОЙ ПАНЕЛИ

	// УСТАНАВЛИВАЕМ ПИНЫ И ПОРТЫ СВЕТОДИОДОВ
	//    *ИСПОЛЬЗУЕТСЯ НЕ const, ЧТО НЕ ЕСТЬ ХОРОШО, НО ПРОБЛЕМ БЫТЬ НЕ ДОЛЖНО
	RGB[0].RED.LED_port = RED_232_GPIO_Port;
	RGB[0].RED.LED_pin = RED_232_Pin;
	RGB[0].GREEN.LED_port = GREEN_232_GPIO_Port;
	RGB[0].GREEN.LED_pin = GREEN_232_Pin;
	RGB[0].BLUE.LED_port = BLUE_232_GPIO_Port;
	RGB[0].BLUE.LED_pin = BLUE_232_Pin;

	RGB[1].RED.LED_port = RED_422_GPIO_Port;
	RGB[1].RED.LED_pin = RED_422_Pin;
	RGB[1].GREEN.LED_port = GREEN_422_GPIO_Port;
	RGB[1].GREEN.LED_pin = GREEN_422_Pin;
	RGB[1].BLUE.LED_port = BLUE_422_GPIO_Port;
	RGB[1].BLUE.LED_pin = BLUE_422_Pin;

	RGB[2].RED.LED_port = RED_485_GPIO_Port;
	RGB[2].RED.LED_pin = RED_485_Pin;
	RGB[2].GREEN.LED_port = GREEN_485_GPIO_Port;
	RGB[2].GREEN.LED_pin = GREEN_485_Pin;
	RGB[2].BLUE.LED_port = BLUE_485_GPIO_Port;
	RGB[2].BLUE.LED_pin = BLUE_485_Pin;

	// УКАЗАТЕЛЬ НА ОТДЕЛЬНЫЙ СВЕТОДИОД С ЕГО ДАННЫМИ (РЕЖИМОМ МИГАНИЯ, ПИНОМ)
	led_status *oneLED;

	// ЗАДЕРЖКА ПРИ ВКЛЮЧЕНИИ ПОКА ИНИЦИАЛИЗИРУЕТСЯ ДИСПЛЕЙ
	osDelay(500);

	for(;;)
	{
		// ПАРСИМ СТРОКУ СВЕТОДИОДОВ
		LEDStringPars((string_t *)&datastring,(RGB_status *) &RGB);



		// ОБРАБАТЫВАЕМ КАЖДЫЙ RGB (3)
		for(uint8_t i = 0; i < 3; i++){

			// ОБРАБАТЫВАЕМ КАЖДЫЙ СВЕТОДИОД В RGB
			for(uint8_t j = 0; j < 3; j++){

				// ВЫБИРАЕМ СВЕТОДИОД УКАЗЫВАЯ НА НУЖНЫЙ
				switch (j){
				case 0: oneLED = &RGB[i].RED;   break;
				case 1: oneLED = &RGB[i].BLUE;  break;
				case 2: oneLED = &RGB[i].GREEN; break;
				}

				// УСТАНАВЛИВАЕМ РЕЖИМ МИГАНИЯ СВЕТОДИОДОМ
				//    *ИСПОЛЬЗУЕТ uint32_t ДЛЯ ХРАНЕНИЯ ПЕРЕМЕННОЙ ВРЕМЕНИ ДЛЯ КАЖДОГО СВЕТОДИОДА
				//     МОЖЕТ БЫТЬ ОПТИМИЗИРОВАНО ПО ПАМЯТИ ДЛЯ КАЖДОГО РЕЖИМА, ЧТО СИЛЬНО УМЕНЬШИТ ПАМЯТЬ
				switch (oneLED->LED_status)
				{
				case (uint8_t)'0': LED_control(oneLED,0,1); 	break;
				case (uint8_t)'1': LED_control(oneLED,1,0); 	break;
				case (uint8_t)'2': LED_control(oneLED,50,100);  break;
				case (uint8_t)'3': LED_control(oneLED,200,200); break;
				case (uint8_t)'4': LED_control(oneLED,50,500);  break;
				}
			}
		}

		osDelay(10);
	}
  /* USER CODE END StartLEDsTask */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/*
 * ОБРАБОТЧИК ПРЕРЫВАНИЙ ТАЙМЕРА UPTIME
 */
void UPTIME_IRQHandler(){
	uptime_tick++;
}


//void WriteToMemory_I2C(uint32_t *data){
////	HAL_I2C_Master_Transmit(&hi2c1,0b001, &i2c_go, 2, 1000);
//}
//
//uint32_t U8toU32(uint8_t *U8){
//	uint32_t U32;
//	U32 = U8[0]<<24;
//	U32 += U8[1]<<16;
//	U32 += U8[2]<<8;
//	U32 += U8[3];
//	return U32;
//}
//
//uint32_t ReadToMemory_I2C(uint8_t addres,uint8_t memry_pointer){
//	uint16_t read_mem[4];
//	HAL_I2C_Master_Transmit(&hi2c1,addres, &memry_pointer, 1, 1000);
//	HAL_I2C_Master_Receive(&hi2c1,addres, &read_mem, 4, 1000);
//
//	return U8toU32(&read_mem);
//}


/*
 * ОБРАБОТЧИК ПРЕРЫВАНИЙ ANALOG WATHDOG
 * ПРИ ОТЛАДКЕ ПЛАТЫ БУДЕТ ПЕРЕПИСАНО, Т.К
 * В ДАННОМ ВАРИАНТЕ ЗАТРУДНЕНО ОТКЛЮЧЕНИЕ ДИСПЛЕЯ
 */
void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc){
	UBaseType_t uxSavedInterruptStatus;

	// ПРОВЕРЯЕМ УСЛОВИЕ, ЧТО ПИТАНИЕ 12 В
	// ЕСЛИ ДА, ТО ПРОДОЛЖАЕМ
	// ЕСЛИ НЕТ, ТО ВКЛЮЧАЕМ ЗУМЕРЫ В ЦИКЛЕ
	// ПИТАНИЕ РАСЧИТАНО ИЗ СХЕМЫ : 				12V/(5.1К + 5.1К + 1К)*1К = 0,29464V
	// ПЕРЕВОДИМ В ЗНАЧЕНИЕ 12 РАЗРЯДНОГО АЦП		0,29464*4095/3.3 = 1329,545
	// БЕРЕМ +-90 (+-0,8V НА ВХОД)
	// ЦИКЛ ЗАЩИЩЕН ФУНКЦИЯМИ FREERTOS
	uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR ();

	while(ADC_val[4] < Low12vThreshold || ADC_val[4] > High12vThreshold){
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);

		HAL_GPIO_WritePin(STM32_Relay_mmn_GPIO_Port, STM32_Relay_mmn_Pin, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(STM32_Relay_mother_GPIO_Port, STM32_Relay_mother_Pin, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(STM32_RS_DC_DC_GPIO_Port, STM32_RS_DC_DC_Pin, GPIO_PIN_RESET);

		// ОБНОВЛЯЕМ WATHDOG
		HAL_IWDG_Refresh(&hiwdg);
	}
	HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
	taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus);
}

void PowerON(u8g2_t* u8g2){
//	UBaseType_t uxSavedInterruptStatus;

	// ПРОВЕРЯЕМ УСЛОВИЕ, ЧТО ПИТАНИЕ 12 В
	// ЕСЛИ ДА, ТО ПРОДОЛЖАЕМ
	// ЕСЛИ НЕТ, ТО ВКЛЮЧАЕМ ЗУМЕРЫ В ЦИКЛЕ
	// ПИТАНИЕ РАСЧИТАНО ИЗ СХЕМЫ : 				12V/(5.1К + 5.1К + 1К)*1К = 1.07142V
	// ПЕРЕВОДИМ В ЗНАЧЕНИЕ 12 РАЗРЯДНОГО АЦП		1.07142*4095/3.3 = 1329,545
	// БЕРЕМ +-90 (+-0,8V НА ВХОД)
	// ЦИКЛ ЗАЩИЩЕН ФУНКЦИЯМИ FREERTOS
//	uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR ();

//	while(ADC_val[4] < 1240 || ADC_val[4] > 1420){
//		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
//
//		// ОБНОВЛЯЕМ WATHDOG
//		HAL_IWDG_Refresh(&hiwdg);
//	}

//	taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus);


	// ЗАЖИГАЕМ СИНИЙ ЦВЕТ RGB ПРИ СТАРТЕ
	HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_SET);

	// ВКЛЮЧАЕМ РЕЛЕ
	HAL_GPIO_WritePin(STM32_Relay_mmn_GPIO_Port, STM32_Relay_mmn_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(STM32_Relay_mother_GPIO_Port, STM32_Relay_mother_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(STM32_RS_DC_DC_GPIO_Port, STM32_RS_DC_DC_Pin, GPIO_PIN_SET);

	// ВКЛЮЧАЕМ ЗУМЕРЫ
	for(uint8_t i = 0; i < 4; i++){
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
		osDelay(30);
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		osDelay(30);
	}

	// ЗАЖИГАЕМ ДИСПЛЕЙ
	u8g2_DrawBox(u8g2,0,0,254,64);
	u8g2_SendBuffer(u8g2);

	// ЖДЕМ
	HAL_Delay(start_pause);

	// ТУШИМ ДИСПЛЕЙ
	u8g2_ClearDisplay(u8g2);

	// ВЫКЛЮЧАЕМ ЗУМЕРЫ
	HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
}

/*
 * ФУНКЦИЯ ОТКЛЮЧЕНИЯ СИСТЕМЫ
 * ОТКЛЮЧАЕТ
 */

void PowerOFF(){

	for(uint8_t i = 0; i < 4; i++){
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
		osDelay(30);
		HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		osDelay(30);
	}

	display_stat = 0;

	osDelay(PowerOFF_delay);

//	vTaskDelete(myDisplayTaskHandle);

	vTaskDelete(myDataTaskHandle);
	vTaskDelete(myLEDsTaskHandle);

	HAL_GPIO_WritePin(STM32_RS_DC_DC_GPIO_Port, STM32_RS_DC_DC_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(STM32_Relay_mother_GPIO_Port, STM32_Relay_mother_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(STM32_Relay_mmn_GPIO_Port, STM32_Relay_mmn_Pin, GPIO_PIN_RESET);

	LEDs_OFF();

	SleepMode();

}

void SleepMode(){
	uint8_t switch_off = 0;
	uint8_t power_butmem = 0;									// ПЕРЕМЕННАЯ ДЛЯ ОТСЧЕТА ВРЕМЕНИ НАЖАТИЯ КНОПКИ
	uint32_t power_butthold = 0;
	uint16_t PWM_val = 0;
//	uint8_t direct = 1;
	double angl = 0;

	while(1){
		HAL_IWDG_Refresh(&hiwdg);

		for(uint16_t i = 0; i < 3000; i++){
			if(i < PWM_val){
				HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_SET);

				HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_SET);
				HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_SET);
			}
			else{
				HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_RESET);

				HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_RESET);
			}
		}

//		if(PWM_val < 3000 && direct){
//			PWM_val++;
//		}
//		if(PWM_val > 0 && !direct){
//			PWM_val--;
//		}
//		if(PWM_val == 0) direct = 1;
//		if(PWM_val >= 3000) direct = 0;

		angl = (angl > 3.141) ? 0 : angl + 0.004;
		PWM_val = (sin(angl)) * 1000;


		PowerButtonHandler(&power_butthold, &power_butmem, &switch_off, 500);

		while(switch_off){

		}
	}
}

void FlashWriteStart(){

}
/*
 * ФУНКЦИЯ ПЕРЕВОДИТ МАЛЕНЬКИЕ БУКВЫ ШЕСТНАДЦАТИРИЧНОГО НАБОРА
 * В БОЛЬШИЕ. ЕСЛИ НА ВХОД ПРИШЛА ЦИФРА, ТО ВОЗВРАЩАЕТСЯ СИМВОЛ ЦИФРЫ
 */
char BigLatter(char smalllatter){
	switch(smalllatter){
	case 'a': return 'A';
	case 'b': return 'B';
	case 'c': return 'C';
	case 'd': return 'D';
	case 'e': return 'E';
	case 'f': return 'F';
	default: return smalllatter;
	}
}

/*
 * ФУНКЦИЯ РАСЧЕТА ТЕМПЕРАТУРЫ ВСТРОЕНОГО ДАТЧИКА STM.
 * ПРИНИМАЕТ ДАННЫЕ АЦП С ТЕМПЕРЕАТУРНОГО КАНАЛА
 * ВОЗВРАЩАЕТ ТЕМПЕРАТУРУ В ГРАДУСАХ ЦЕЛЬСИЯ
 */
uint8_t TemperatureGetData(uint16_t ADCResult){
	int32_t temperature; /* will contain the temperature in degrees Celsius */

	temperature = (((int32_t) ADCResult * VDD_APPLI / VDD_CALIB) - (int32_t) *TEMP30_CAL_ADDR );
	temperature = temperature * (int32_t)(110 - 30);
	temperature = temperature / (int32_t)(*TEMP110_CAL_ADDR - *TEMP30_CAL_ADDR);

    return (uint8_t) temperature + 25;
}

/*
 * КЛАДЕТ ТЕКСТ ОШИБКИ В 1-Ю СТРОКУ КОНТРОЛЬНЫХ СТРОК
 */
void PutERROR(string_t *error_string,const char *error_tekst){

	// ЧИСТИМ СТРОКУ
	for(uint8_t i = 0; i < string_size; i++){
		error_string[start_ctrl_string].buf[i] = '\0';
	}

	// ЗАПОЛНЯЕМ СТРОКУ
	for(uint8_t i = 0; i < strlen(error_tekst); i++){
		error_string[start_ctrl_string].buf[i] = error_tekst[i];
	}
}

void PowerButtonHandler(uint32_t *butthold,uint8_t *butmem, uint8_t *switch_off, uint16_t off_delay){

	// ЕСЛИ КНОПКА НАЖАТА
	if(HAL_GPIO_ReadPin(STM32_BUTTON_POWER_GPIO_Port, STM32_BUTTON_POWER_Pin)){

		HAL_GPIO_WritePin(STM32_BUTTON_LED_POWER_GPIO_Port, STM32_BUTTON_LED_POWER_Pin, GPIO_PIN_RESET);

		// ЕСЛИ КНОПКА ДО ЭТОГО НЕ БЫЛА НАЖАТА
		if(!(*butmem &  STM32_BUTTON_POWER_Pin)){

			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

			// НАЧИНАЕТ ОТСЧЕТ ВРЕМЕНИ
			*butthold = HAL_GetTick();
		}
		// ЕСЛИ ПРОШЛО ОПРЕДЕЛЕННОЕ ВРЕМЯ И КНОПКА ВСЕ ЕЩЕ НАЖАТА, ТО ПОДНИМАЕМ ФЛАГ
		if((HAL_GetTick() - *butthold) > off_delay){

			*switch_off = 1;

		}
	}

	*butmem = STM32_BUTTON_POWER_GPIO_Port->IDR;		// ПАМЯТЬ КНОПКИ
}



/*
 * ФУНКЦИЯ ОБРАБОТКИ КНОПОК
 */
void ScrollingButtonHandler(uint8_t *cursor, uint32_t *butthold,uint8_t *butmem){

	// ЕСЛИ КНОПКА НАЖАТА И (НЕ БЫЛА ЕЩЕ НАЖАТА, ИЛИ ПРОШЛО МНОГО ВРЕМЕНИ)
	// УСЛОВИЕ РАБОТАЕТ НА ОДИНОЧНЫЕ НАЖАТИЯ, НО ЕСЛИ ПРОШЛО ОПРЕДЕЛЕННОЕ ВРЕМЯ,
	// ПАМЯТЬ НАЖАТИЯ КНОПКИ НЕ УЧИТЫВАЕТСЯ
	if(HAL_GPIO_ReadPin(STM32_BUTTON_1_GPIO_Port, STM32_BUTTON_1_Pin)){

		HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_RESET);

		if(!(*butmem & STM32_BUTTON_1_Pin) || (HAL_GetTick() - *butthold > scroll_delay)){

			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

			*cursor = (*cursor < (160 - 4)) ? *cursor + 1 : *cursor;
			osDelay(1000/scroll_speed);
			uptime = uptime_tick;
			if(!(*butmem & STM32_BUTTON_1_Pin))
				*butthold = HAL_GetTick();
		}
	}
	else {
		HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_SET);
	}

	// 2 АНАЛОГИЧНО
	if(HAL_GPIO_ReadPin(STM32_BUTTON_2_GPIO_Port, STM32_BUTTON_2_Pin)){

		HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_RESET);

		if(!(*butmem & STM32_BUTTON_2_Pin) || ((HAL_GetTick() - *butthold) > scroll_delay)){

			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

			*cursor = (*cursor > 0) ? *cursor - 1 : 170;
			osDelay(1000/scroll_speed);
			uptime = uptime_tick;

			if(!(*butmem & STM32_BUTTON_2_Pin))
				*butthold = HAL_GetTick();
			}

	}
	else HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_SET);

	//3
	if(HAL_GPIO_ReadPin(STM32_BUTTON_3_GPIO_Port, STM32_BUTTON_3_Pin)){

			HAL_GPIO_WritePin(STM32_BUTTON_LED_3_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_RESET);

			if(!(*butmem & STM32_BUTTON_3_Pin) || ((HAL_GetTick() - *butthold) > scroll_delay)){

				HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
				osDelay(Button_Zummer);
				HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);

				uptime = uptime_tick;
				if(!(*butmem & STM32_BUTTON_3_Pin))
					*butthold = HAL_GetTick();
				}

		}
		else HAL_GPIO_WritePin(STM32_BUTTON_LED_3_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_SET);


	*butmem = STM32_BUTTON_LED_1_GPIO_Port->IDR;						 // т.к_порт_кнопок_один
}

void ServiceModeButtonHandler(uint8_t *mem, uint32_t *hold, uint16_t service_delay){

	if(HAL_GPIO_ReadPin(STM32_BUTTON_1_GPIO_Port, STM32_BUTTON_1_Pin)
			&& HAL_GPIO_ReadPin(STM32_BUTTON_2_GPIO_Port, STM32_BUTTON_2_Pin)){

		// ЕСЛИ КНОПКА ДО ЭТОГО НЕ БЫЛА НАЖАТА
		if(!(*mem &  STM32_BUTTON_POWER_Pin)){

			// НАЧИНАЕТ ОТСЧЕТ ВРЕМЕНИ
			*hold = HAL_GetTick();
		}
		// ЕСЛИ ПРОШЛО ОПРЕДЕЛЕННОЕ ВРЕМЯ И КНОПКА ВСЕ ЕЩЕ НАЖАТА, ТО ПОДНИМАЕМ ФЛАГ
		if((HAL_GetTick() - *hold) > service_delay){

			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(20);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
			osDelay(30);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(20);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		}
	}
}
void ConnHandler(uint8_t *mem){

	if(HAL_GPIO_ReadPin(STM32_Conn_1_GPIO_Port, STM32_Conn_1_Pin)){

		if(!(*mem & STM32_Conn_1_Pin)){
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		}
	}

	if(HAL_GPIO_ReadPin(STM32_Conn_2_GPIO_Port, STM32_Conn_2_Pin)){

		if(!(*mem & STM32_Conn_2_Pin)){
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_SET);
			osDelay(Button_Zummer);
			HAL_GPIO_WritePin(STM32_ZUMMER_GPIO_Port, STM32_ZUMMER_Pin, GPIO_PIN_RESET);
		}
	}

	*mem = STM32_Conn_1_GPIO_Port->IDR;		// ПАМЯТЬ КНОПКИ
}

/*
 * ФУНКЦИЯ РАСЧЕТ CRC32. КЛАДЕТ ВСЕ СИМВОЛЫ ПОСЛЕ "PSD;"
 * И ДО "CRC" В МАССИВ crc32_buf, ПОСЛЕ ЧЕГО СЧИТАЕТ КОНТРОЛЬНУЮ СУММУ.
 * ВОЗВРАЩАЕТ 1 ЕСЛИ КОНТРОЛЬНЫЕ СУММЫ СОШЛИСЬ
 * ВОЗВРАЩАЕТ 0 ЕСЛИ СУММА НЕ СОШЛАСЬ ИЛИ ПАКЕТ ПОВРЕЖДЕН
 */
uint8_t CRC32_Status(uint8_t *buf, size_t buf_size, uint16_t pointer, buffer_t *crc32_buf){

	uint8_t crc_in_buf[8];												// СИМВОЛЬНЫЙ БУФЕР ВХОДНОГО ЗНАЧЕНИЯ CRC32
	uint8_t crc_string_count = 0;										// СЧЕТЧИК
	uint32_t crc_in = 0;												// ВХОДНОЕ ЗНАЧЕНИЕ CRC32
	uint32_t crc_out = 0;												// РАСЧИТАНОЕ ЗНАЧЕНИЕ СRC32
	uint16_t crc_pointer = pointer;										// УКАЗАТЕЛЬ ДЛЯ НАБОРА МАССИВА CRC32

	uint16_t crc_count = string_pack_amount * string_size;				// МАКСИМАЛЬНОЕ КОЛИЧЕСТВО СИМВОЛОВ В ПАКЕТЕ

	// ОБНУЛЯЕМ ХВОСТ БУФЕРА
	crc32_buf->tail = 0;

	// ПОКА БУФЕР НЕ ЗАКОНЧИТСЯ
	while(crc_count){

		// ЕСЛИ НАЙДЕНА СТАРТОВАЯ КОМБИНАЦИЯ, ЗНАЧИТ ЧТО-ТО НЕ ТАК
		if(FindString((uint8_t *)buf, buf_size, &crc_pointer, "PDS", 3)){
			//место_для_вашей_ошибки
			return 0;
		}

		// ЕСЛИ НАЙДЕН "CRC", ЗНАЧИТ МАССИВ НАБРАН. ПРИСТУПАЕМ К РАСЧЕТУ
		if(FindString((uint8_t *)buf, buf_size, &crc_pointer, "CRC", 3)){

			// ПРОПУСКАЕМ ';'
			PassSym((uint8_t *)&buf, buf_size, &crc_pointer, 1);

			// РАСЧИТЫВАЕМ CRC32 ИЗ МАССИВА
			crc_out = Crc32((const unsigned char*)crc32_buf, crc32_buf->tail);
			crc_in = 0;

			if(FindString(buf, buf_size, &crc_pointer, "NAN", 3)){
				PutERROR((string_t *)&datastring,"CRC_NAN");
				return 1;
			}

			// ПАРСИМ ЗНАЧЕНИЕ CRC32 ИЗ ПАКЕТА
			while(buf[crc_pointer] != (uint8_t)';' && (crc_string_count < 8)){
				crc_in_buf[crc_string_count] = buf[crc_pointer];

				// ПЕРЕВОДИМ ПОЛУЧЕНУЮ СТРОКУ В DEC
				crc_in = HexToDec((char *)&crc_in_buf,8);

				// ВЫВОЖУ СRC В 0-Ю СТРКОУ ДЛЯ ОТЛАДКИ
				datastring[0].buf[crc_string_count] = buf[crc_pointer];

				PassSym((uint8_t *)&buf, buf_size, &crc_pointer, 1);
				crc_string_count++;
			}

			// СРАВНИВАЕМ ЗНАЧЕНИЯ, ВЫВОДИМ СООТВЕТСТВУЮЩЕЕ СОСТОЯНИЕ CRC
			if(crc_in == crc_out){
				PutERROR((string_t *)&datastring,"CRC_OK");

				return 1;
			}
			else{
				PutERROR((string_t *)&datastring,"CRC_ERROR");
				return 0;
			}
			break;
		}
		PassSymCRC((uint8_t *)buf, buf_size, &crc_pointer, 1, crc32_buf);
		crc_count--;
	}

	// ЕСЛИ БУФЕР ЗАКНОЧИЛСЯ И CRC НЕ БЫЛ НАЙДЕН
	if(!crc_count){
		PutERROR((string_t *)&datastring,"CRC NOT FOUND");
		return 0;
	}
	return 0;
}

/* ФУНКЦИЯ ПОИСКА ПОДСТРОКИ(ПОСЛЕДОВАТЛЬНОСТИ СИМВОЛОВ) В ИСХОДНОМ МАССИВЕ
 * ЕСЛИ ПОСЛЕДОВАТЕЛЬНОСТЬ ОБНАРУЖЕНА ВОЗВРАЩАЕТ 1 И ЗНАЧЕНИЕ ИНДЕКС pointer НА СЛЕДУЮЩИЙ
 * СИМВОЛ ПОСЛЕ ИСКОМОЙ СТРОКИ.
 * ЕСЛИ ПОСЛЕДОВАТЕЛЬНОСТЬ НЕ ОБНАРУЖЕНА, ТО ВОЗРАЩАЕТ 0 И НЕ МЕНЯЕТ pointer
 */
uint8_t FindString(uint8_t *buf,size_t buf_size,uint16_t *pointer,const char *str,size_t str_size){
	uint8_t count = 0;
	uint16_t p = *pointer;
	while(count < str_size){
		if(buf[p] == (uint8_t)str[count]){
			p = (p < buf_size - 1) ? p + 1 : 0;
			count++;
		}
		else return 0;
	}

	*pointer = p;
	return 1;
}

/*
 *  ФУНКЦИЯ МИГАЕТ СВЕТОДИОДАМ ОПИСАНЫМ СТРУКТУРОЙ led_status
 *  ON_time ЗАДАЕТ ВРЕМЯ, КОТОРОЕ СВЕТОДИОД ВКЛЮЧЕН
 *  OFF_time ЗАДАЕТ ВРЕМЯ, КОТОРОЕ СВЕТОДИД ВЫКЛЮЧЕН
 */
void LED_control(led_status *oneLED, uint16_t ON_time, uint16_t OFF_time){

	if(OFF_time == 0 && ON_time != 0){
		HAL_GPIO_WritePin(oneLED->LED_port, oneLED->LED_pin, GPIO_PIN_SET);
		return;
	}

	if(ON_time == 0 && OFF_time != 0){
		HAL_GPIO_WritePin(oneLED->LED_port, oneLED->LED_pin, GPIO_PIN_RESET);
		return;
	}


	if(HAL_GetTick() - oneLED->timer < ON_time){
		HAL_GPIO_WritePin(oneLED->LED_port, oneLED->LED_pin, GPIO_PIN_SET);
	}
	else if(HAL_GetTick() - oneLED->timer < ON_time + OFF_time){

		HAL_GPIO_WritePin(oneLED->LED_port, oneLED->LED_pin, GPIO_PIN_RESET);
	}
	else oneLED->timer = HAL_GetTick();
}

void LEDs_OFF(){
	HAL_GPIO_WritePin(RED_232_GPIO_Port, RED_232_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GREEN_232_GPIO_Port, GREEN_232_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BLUE_232_GPIO_Port, BLUE_232_Pin, GPIO_PIN_RESET);

	HAL_GPIO_WritePin(RED_485_GPIO_Port, RED_485_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GREEN_485_GPIO_Port, GREEN_485_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BLUE_485_GPIO_Port, BLUE_485_Pin, GPIO_PIN_RESET);

	HAL_GPIO_WritePin(RED_422_GPIO_Port, RED_422_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GREEN_422_GPIO_Port, GREEN_422_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BLUE_422_GPIO_Port, BLUE_422_Pin, GPIO_PIN_RESET);

	HAL_GPIO_WritePin(STM32_BUTTON_LED_1_GPIO_Port, STM32_BUTTON_LED_1_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(STM32_BUTTON_LED_2_GPIO_Port, STM32_BUTTON_LED_2_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(STM32_BUTTON_LED_3_GPIO_Port, STM32_BUTTON_LED_3_Pin, GPIO_PIN_RESET);
}

/*
 * ФУНКЦИЯ ПРОПУСКАЕТ УКАЗАНОЕ КОЛИЧЕСТВО СИМВОЛОВ sym_amount
 * C УЧЕТОМ ЦИКЛИЧНОСТИ БУФЕРА. ПРОПУЩЕНЫЕ СИМВОЛЫ НЕ УЧИТЫВАЮТСЯ ПРИ РАСЧЕТЕ CRC32
 * pointer_ - УКАЗАТЕЛЬ НА ТЕКУЩИЙ ЭЛЕМЕНТ
 * sym_amount - КОЛИЧЕСТВО ПРОПУСКАЕМЫХ СИМВОЛОВ
 */
void PassSym(uint8_t *buf, size_t buf_size, uint16_t *pointer, uint8_t sym_amount){
	for(uint8_t i = 0; i < sym_amount; i++){
		*pointer = (*pointer < buf_size-1) ? *pointer + 1 : 0;
	}
}

/* ФУНКЦИЯ ПРОПУСКАЕТ УКАЗАНОЕ КОЛИЧЕСТВО СИМВОЛОВ sym_amount
 * C УЧЕТОМ ЦИКЛИЧНОСТИ БУФЕРА. ПРОПУЩЕНЫЕ СИМВОЛЫ УЧИТЫВАЮТСЯ ПРИ РАСЧЕТЕ CRC32*/
void PassSymCRC(uint8_t *buf,size_t buf_size,uint16_t *pointer, uint8_t sym_amount,buffer_t *crc_buf){
	for(uint8_t i = 0; i < sym_amount; i++){
		CRC32_Put(crc_buf,buf[*pointer]);
		*pointer = (*pointer < buf_size-1) ? *pointer + 1 : 0;
	}
}

/*
 * ФУНКЦИЯ ПЕРЕВОДИТ 16-РАЗРЯДНОЕ ЧИСЛО, ЗАПИСАННОЕ В МАССИВЕ СИМВОЛОВ
 * В 10-РАЗРЯДНОЕ ИНТОВОЕ ЗНАЧЕНИЕ.
 */
uint32_t HexToDec(char *hex,uint8_t size){
	uint32_t dec = 0;

	for(uint8_t i = 0; i < size;i++){
		switch (hex[i]){
		case 'A': dec += 10 * pow(16,size-1 - i); break;
		case 'B': dec += 11 * pow(16,size-1 - i); break;
		case 'C': dec += 12 * pow(16,size-1 - i); break;
		case 'D': dec += 13 * pow(16,size-1 - i); break;
		case 'E': dec += 14 * pow(16,size-1 - i); break;
		case 'F': dec += 15 * pow(16,size-1 - i); break;

		case '1': dec += 1 * pow(16,size-1 - i); break;
		case '2': dec += 2 * pow(16,size-1 - i); break;
		case '3': dec += 3 * pow(16,size-1 - i); break;
		case '4': dec += 4 * pow(16,size-1 - i); break;
		case '5': dec += 5 * pow(16,size-1 - i); break;
		case '6': dec += 6 * pow(16,size-1 - i); break;
		case '7': dec += 7 * pow(16,size-1 - i); break;
		case '8': dec += 8 * pow(16,size-1 - i); break;
		case '9': dec += 9 * pow(16,size-1 - i); break;
		case '0': dec += 0; break;
		}
	}
	return dec;
}

/*
 * ФУНКЦИЯ ПАРСИНГА СТРОК СВЕТОДИОДОВ
 *
 */
void LEDStringPars(string_t *datastring, RGB_status *leds){

	// Т.К. 3 RGB
	for(uint8_t i = 0; i < 3; i++){
		uint8_t pointer = 0;
		while(pointer < 6){
			switch(datastring[serv_string_1].buf[pointer]){
			case (uint8_t)'R': leds[i].RED.LED_status = datastring[serv_string_1].buf[pointer+1]; break;
			case (uint8_t)'G': leds[i].GREEN.LED_status = datastring[serv_string_1].buf[pointer+1]; break;
			case (uint8_t)'B': leds[i].BLUE.LED_status = datastring[serv_string_1].buf[pointer+1]; break;
			}
			pointer++;
		}
	}
}

/*
 * ФУНКЦИЯ СТРОКИ, УПРАВЛЯЮЩИЕ РЕЛЕ, DC И ДСИПЛЕЕМ
 */
void ServiceStringPars(string_t *datastring, ctrl_status *active){
	active->RELE[0] = (datastring[serv_string_2].buf[1] == '1') ? 1 : 0;
	active->RELE[1] = (datastring[serv_string_2].buf[3] == '1') ? 1 : 0;
	active->RELE[2] = (datastring[serv_string_2].buf[5] == '1') ? 1 : 0;
	active->RELE[3] = (datastring[serv_string_2].buf[7] == '1') ? 1 : 0;
	active->DC = datastring[serv_string_2].buf[10] - 48;
	active->DISP = datastring[serv_string_2].buf[15] - 48;
}

/*
 * ОБРАБОТЧИК ПРЕРЫВАНИЙ ПОЛОВИНЫ ПЕРЕПОЛНЕНИЯ БУФЕРА uatrt_buf
 */
void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart){
	uart_hlf_flag = 1;
}

/*
 * фУНКЦИЯ ИНИЦИАЛИЗАЦИИ ДИСПЛЕЯ
 */
void DisplayInit(u8g2_t* u8g2){
	u8g2_Setup_ssd1322_nhd_256x64_f(u8g2, U8G2_R0, u8x8_byte_4wire_hw_spi, u8x8_stm32_gpio_and_delay);
	u8g2_InitDisplay(u8g2);
	u8g2_ClearDisplay(u8g2);
	u8g2_SetPowerSave(u8g2, 0);
}
//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
//	GPIOD->ODR ^= 1<<13;
//	HAL_UART_Receive_IT(&huart3, (uint8_t*)uart_buf,UartBufSize);
//}
/* USER CODE END Application */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
